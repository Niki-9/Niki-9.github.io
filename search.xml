<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何建模一台cafe racer摩托车by SW</title>
      <link href="/cafe%20racer/"/>
      <url>/cafe%20racer/</url>
      
        <content type="html"><![CDATA[<p>&#x2F;Users&#x2F;macbookpro&#x2F;Documents&#x2F;blog1&#x2F;public&#x2F;img&#x2F;WechatIMG877.jpeg</p><p>&#x2F;Users&#x2F;macbookpro&#x2F;Documents&#x2F;blog1&#x2F;public&#x2F;img&#x2F;WechatIMG878.jpeg</p><p>&#x2F;Users&#x2F;macbookpro&#x2F;Documents&#x2F;blog1&#x2F;public&#x2F;img&#x2F;WechatIMG879.jpeg</p><p>&#x2F;Users&#x2F;macbookpro&#x2F;Documents&#x2F;blog1&#x2F;public&#x2F;img&#x2F;WechatIMG880.jpeg</p><p>&#x2F;Users&#x2F;macbookpro&#x2F;Documents&#x2F;blog1&#x2F;public&#x2F;img&#x2F;WechatIMG881.jpeg</p><p>&#x2F;Users&#x2F;macbookpro&#x2F;Documents&#x2F;blog1&#x2F;public&#x2F;img&#x2F;WechatIMG882.jpeg</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>###四个隔离级别</p><ol><li>读未提交，允许读取尚未提交的数据，脏读，幻读，不可重复读</li><li>读已提交，读取已经提交的数据，阻止脏读</li><li>可重复读，对同一字段的读取结果都是一致，除非本身修改，阻止脏读和不可重复读</li><li>可串行化，所有都能重复，解决幻读：其他事务进行了添加或删除操作，本事务查询时出现多个数据</li></ol><p>###MySQL执行过程<br>连接器进行身份权限验证，<br>查询缓存，命中则直接返回<br>分析器，没有命中，则经过分析器，分析sql语句的目的并检查语法<br>优化器，按照MySQL认为的最优的方案执行<br>执行器，执行，返回结果</p><p>###数据库范式</p><ol><li>1NF(第一范式)：属性不可再分</li><li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖</li><li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点记录</title>
      <link href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>###操作系统功能</p><ol><li>进程和线程的管理</li><li>存储管理</li><li>文件管理</li><li>设备管理</li><li>网络管理</li><li>安全管理</li></ol><p>###用户态和内核态</p><ol><li>用户态(User Mode) : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态</li><li>内核态(Kernel Mode)：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态</li></ol><p>用户态的出现是为了减少负担，保证计算机运行程序的稳定和安全，减少访问计算机内核，内存，磁盘等的频率</p><p>###用户态切换到内核态的方式</p><ol><li>系统调用，在用户态运行的程序人为的申请系统调用去访问内核态才能访问的资源<br>系统调用过程，首先用户态程序发起系统调用，然后系统处理中断操作，内核态开始运行，处理完之后再次中断，切换回用户态</li><li>中断，外围设备发出信号后，CPU会执行处理中断操作的程序，即内核态的程序</li><li>异常，出现异常的时候，系统会切换到处理异常的程序中，即内核态</li></ol><p>###进程和线程</p><ol><li>进程（Process） 是指计算机中正在运行的一个程序实例。举例：你打开的微信就是一个进程。</li><li>线程（Thread） 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。</li></ol><p>###线程间的同步</p><ol><li>互斥锁，互斥对象，只有拥有互斥对象的线程才能访问资源</li><li>读写锁</li><li>信号量，设置对资源访问的最大线程数量</li><li>屏障，一个线程到达屏障后会等待其他线程</li><li>事件，通知操作实现线程同步</li></ol><p>###线程状态</p><ol><li>创建</li><li>就绪</li><li>运行</li><li>阻塞</li><li>结束</li></ol><p>###线程间通信</p><ol><li>管道，在内存中，具有亲缘关系的线程通信</li><li>有名管道，在磁盘中，先进先出，针对所有线程</li><li>信号，通知进程</li><li>消息队列，消息的链表结构，在内核中，比先进先出有优势，可以随机查询</li><li>信号量，解决线程间的同步问题</li><li>共享内存</li><li>套接字</li></ol><p>###进程的调度算法</p><ol><li>先到先服务算法，从就绪队列中选取最先进入的进程为其分配资源</li><li>短作业优先算法，从队列中选取作业时间最短的进程</li><li>时间片轮转，为每一个进程分配一个时间片</li><li>多级反馈队列，结合优先级和短作业</li><li>优先级</li></ol><p>###死锁<br>描述的是这样一种情况：多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止</p><p>###死锁四个必要条件</p><ol><li>互斥，资源只能一个进程使用</li><li>占有等待，进程必须占有至少一个资源并处于等待其他资源的状态</li><li>非抢占，资源被使用后必须被释放才能被再次使用</li><li>形成循环关系</li></ol><p>###死锁的预防<br>改变资源分配的策略，一个进程一次性拿全部的资源或者按照层次分配，一个进程拿资源必须拿本层次之上的资源</p><p>###死锁避免<br>银行家算法，将资源分配给该进程，然后判断情况下会不会出现死锁，会就取消分配</p><p>###内存管理的方式</p><ol><li>连续内存管理：为一个用户程序分配一个连续的内存空间，内存利用率一般不高</li><li>非连续内存管理：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些<br>非连续：段式，页式，段页式</li></ol><p>###页面置换算法</p><ol><li>最佳页面，淘汰不常使用的页面</li><li>先进先出，淘汰最先进入内存的页面</li><li>最近最久未使用LRU，使用计时器记录该页面上次使用到现在的时间，时间最长的淘汰，使用后更新计时器</li><li>最少使用</li><li>时钟页面，最近未使用</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常见知识点总结</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>##计算机网络<br>###应用层常见协议</p><ol><li>HTTP（Hypertext Transfer Protocol，超文本传输协议）：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li><li>POP3&#x2F;IMAP（邮件接收协议）：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li><li>FTP（File Transfer Protocol，文件传输协议） : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li><li>Telnet（远程登陆协议）：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li><li>SSH（Secure Shell Protocol，安全的网络传输协议）：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li><li>RTP（Real-time Transport Protocol，实时传输协议）：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li><li>DNS（Domain Name System，域名管理系统）: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li></ol><p>###传输层常见协议</p><ol><li>TCP（Transmission Control Protocol，传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。</li><li>UDP（User Datagram Protocol，用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。</li></ol><p>###网络层常见协议</p><ol><li>IP（Internet Protocol，网际协议）：TCP&#x2F;IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li>ARP（Address Resolution Protocol，地址解析协议）：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li><li>ICMP（Internet Control Message Protocol，互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li><li>NAT（Network Address Translation，网络地址转换协议）：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li><li>OSPF（Open Shortest Path First，开放式最短路径优先） ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li><li>RIP(Routing Information Protocol，路由信息协议）：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li><li>BGP（Border Gateway Protocol，边界网关协议）：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li></ol><p>###输入URL到页面展示的过程<br>浏览器先查找域名对应的IP，经过浏览器缓存，路由器缓存，DNS缓存查找，后发送HTTP请求，携带cookie信息给web服务器，服务器接收请求并处理，头部，cookie等，生成HTML响应，发送给浏览器，浏览器接收解析渲染并展示。</p><p>###HTTP和HTTPS区别</p><ol><li>端口号不一样，HTTP是80，HTTPS是443</li><li>URL前缀不一样</li><li>安全性和消耗性不一样，HTTP建立在TCP之上，传输的数据为明文，不安全，HTTPS建立在SSL&#x2F;TLS上，数据会经过加密处理，更安全</li></ol><p>###HTTP1.0和HTTP1.1</p><ol><li>连接方式不同，1.0为短连接，1.1支持长连接</li><li>1.1额外增加了大量的状态响应码</li><li>1.1增加了更多的缓存控制策略</li><li>消耗带宽不一样，1.1允许只将需要的那一部分对象进行传输</li></ol><p>###HTTP1.1和HTTP2.0</p><ol><li>IO多路复用，2.0允许在同一个连接上进行多次请求响应，1.1一次请求只能对应一次连接</li><li>传输格式不一样，2.0为二进制帧，1.1为文本格式，2.0更高效</li><li>2.0支持头部压缩</li><li>2.0支持服务器将资源之外的其他相关资源一并推送给客户端</li></ol><p>###HTTP2.0和HTTP3.0</p><ol><li>传输协议不一样，新增QUIC协议，即可靠又安全</li><li>避免三次握手浪费时间，3.0在第一次握手时会发送数据</li><li>减少队头阻塞，建立多个不同的数据流</li><li>有更好的数据错误恢复重传机制</li></ol><p>###UDP和TCP</p><ol><li>TCP面向连接，UDP不用建立连接</li><li>TCP可靠，UDP不可靠</li><li>TCP有状态，UDP无</li><li>UDP传输效率更快</li><li>传输形式，TCP字节流，UDP报文</li><li>TCP首部开销大</li><li>TCP只能点对点，UDP能一对多</li></ol><h3 id="三握四挥"><a href="#三握四挥" class="headerlink" title="三握四挥"></a>三握四挥</h3><p>客户端向服务端发送请求建立客户端连接后自己处于等待状态，服务端收到后回复，同时请求服务端连接，然后处于等待状态，客户端最后收到发来的回复信息后回传给服务端确认信息，客户端开启。最后服务端收到后也开启</p><p>AB打电话，A说完之后告诉B我说完了（一），B说我知道了（二），此时B还有话，等B说完之后会跟A说，好了我也说完了（三），A说我知道了（四）然后开始等2MSL，B收到后挂断电话，2MSL后A听到B没话了就挂断电话</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础整理笔记中</title>
      <link href="/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E4%B8%AD/"/>
      <url>/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>记录一些关于Java基础的常见知识点</p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h3 id="Java学习第十章"><a href="#Java学习第十章" class="headerlink" title="Java学习第十章"></a>Java学习第十章</h3><p><strong>类变量和类方法</strong></p><p>类变量(静态变量)：为了解决一个问题，避免独立的变量与类结合编程，使得变量可以让所有的类共享，static</p><p>在Child类里面写：</p><p>public static int count &#x3D; 0;——该变量最大的特点就是可以被所有该类的对象共享，所有对象的count都指向同一个空间</p><p>且类变量可以直接通过类名.来访问(Child.count), 它和child1.count，child2.count值是一样的</p><p>静态变量两种说法：1. 存放在堆空间中，count静态变量存放在类对应的class实例对象的尾部，而这个class对象在堆中，所以认为静态变量也在堆中(<strong>静态变量会在类加载的时候就会生成，所以没有创建对象实例也可以访问</strong>) (JDK8之后)，2.存放在方法区的静态域</p><p><strong>类变量使用细节：</strong></p><p>当需要用到每个对象都需要用到的变量时就可以做成类变量(static静态变量)</p><p><strong>类方法同理</strong>：比如Math类，如果希望不创建实例对象也可以调用该类的方法，即将它当作一个工具，则这时可以将它做成静态方法</p><p>静态方法只能访问静态成员(静态变量和静态方法)，<strong>且不能用this关键字</strong></p><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>mian方法是Java虚拟机在调用的，且必须是public因为不在一个类</p><p>必须是static，java虚拟机执行时不必要创建对象</p><p>String args形参数组在程序执行时在命令行将字符串数组传入(java Test jack smith john)</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>属于类的成员，类似于方法，只有方法体</p><p>可以修饰符，写static表示静态代码块{</p><p>​……</p><p>}</p><p>相当于另一种形式的构造器，也可以初始化操作</p><p>若多个构造器中有重复的语句，就可以抽出来写在代码块中</p><p>后续不管调用哪个构造器，都会<strong>先</strong>调用代码块中的内容</p><p><strong>静态代码块</strong></p><p>随类的加载而执行，<strong>只会执行一次</strong>，那么什么时候类加载？</p><ol><li>当创建实例对象new的时候</li><li>创建子类实例对象，父类也会被加载，且父类先被加载，子类再被加载</li><li>使用类的静态属性或静态方法时会被加载，若有父类，则还是先加载父类</li></ol><p>而普通代码块每被<strong>创建一次对象</strong>就会被执行</p><p><em><strong>创建一个对象时在一个类里面的调用顺序：</strong></em></p><ol><li>先执行静态代码块和静态属性初始化，二者优先级一样，若同时存在，则看谁先写，即谁先定义</li><li>直接去看子类构造器，跳到构造器规则：<ol><li>先super到父类的构造器，若父类往上就没有父类了，然后就搞父类的普通代码块和普通属性初始化</li><li>看谁写在前面，先执行谁，都执行完后再真正执行父类构造器，然后回到子类</li><li>看子类的普通代码块和普通属性初始化谁在前</li><li>最后真正执行子类的构造器内容</li></ol></li></ol><p><em><strong>构造器规则：</strong></em></p><p>public A {</p><p>这里会隐藏一个super()，第二行隐藏了调用本类代码块，所以先调用父类的构造器，然后看父类有没有普通代码块，然后再回来执行自己的代码块</p><p>}</p><p>Note：</p><ol><li>静态代码块只能调用静态成员，普通代码块可以调用任意成员</li><li>类的加载，比如主方法想要调用静态属性的时候就会完成类的加载，注意这里类的加载是整体的，也就是静态属性初始化和静态代码块会直接按顺序执行完毕，代码块的内容被执行，这个过程不能断开</li><li>静态属性初始化，这里的属性有可能是创建的另一个类的对象</li></ol><h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><p>单个实例简称单例</p><p>目的是保证在程序运行过程中保证一个类只能有一个实例对象</p><p>饿汉式：</p><ol><li>构造器私有化，防止用户直接new对象</li><li>类的内部创建对象</li><li>向外公开一个静态的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">g1</span> <span class="operator">=</span> GirlFriend.getGirlFriend(); <span class="comment">//接收对象，不管定义几个g1，接收的都是同一个对象</span></span><br><span class="line">        <span class="comment">//这里因为getGirlFriend是静态公开的，所以这里可以直接用类名调用</span></span><br><span class="line">        System.out.println(g1); <span class="comment">//输出对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//私有化姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123; <span class="comment">//私有化构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">girlFriend</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;小红&quot;</span>); </span><br><span class="line">    <span class="comment">//创建对象必须静态，因为get方法是静态的，get里要调用的对象也必须是静态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getGirlFriend</span><span class="params">()</span> &#123; <span class="comment">//静态方法为了让主方法可以用类名调用</span></span><br><span class="line">        <span class="keyword">return</span> girlFriend; <span class="comment">//如果对象不是静态初始化的话，这里会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">//可以输出对象的属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是饿汉式可能会造成创建了对象，但是没有使用，造成资源的浪费</p><p>懒汉式只是用的时候才创建</p><p>懒汉式：</p><ol><li><p>构造器私有化</p></li><li><p>内部先定义一个对象引用名，用来后续接收对象</p></li><li><p>创建静态公开的get方法供主方法调用</p></li><li><p>再get内if语句，判断现在的对象是不是空的，如果不是，说明已经创建了一个对象，就不需要再创建</p><p>若是空的，则创建new一个对象实例赋给之前的对象引用名</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">g1</span> <span class="operator">=</span> GirlFriend.getGirlFriend(); <span class="comment">//接收对象，不管定义几个g1，接收的都是同一个对象</span></span><br><span class="line">        <span class="comment">//这里因为getGirlFriend是静态公开的，所以这里可以直接用类名调用</span></span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">g2</span> <span class="operator">=</span> GirlFriend.getGirlFriend();</span><br><span class="line">        System.out.println(g1); <span class="comment">//输出对象</span></span><br><span class="line">        System.out.println(g2); <span class="comment">//输出对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//私有化姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123; <span class="comment">//私有化构造器，外部不能再new</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GirlFriend girlFriend; <span class="comment">//不给对象属性值，只定义对象引用名，所以默认对象为空null</span></span><br><span class="line">    <span class="comment">//创建对象必须静态，因为get方法是静态的，get里要调用的对象也必须是静态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getGirlFriend</span><span class="params">()</span> &#123; <span class="comment">//静态方法为了让主方法可以用类名调用</span></span><br><span class="line">        <span class="keyword">if</span>(girlFriend == <span class="literal">null</span>) &#123; <span class="comment">//判断此时对象是不是空</span></span><br><span class="line">            girlFriend = <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;小红&quot;</span>); <span class="comment">//如果是空，则利用构造器给对象引用名赋值，真正创建对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> girlFriend; <span class="comment">//返回对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">//可以输出对象的属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ol><li><p>希望这个类就是最终的子类，不希望再被继承被重写</p><p>final class A，这样别的类就不能再继承A了</p></li><li><p>可以用final修饰方法，这样这个方法就不会被子类的方法重写</p><p>public final void hi()</p></li><li><p>用final修饰属性，这样类的属性就不会被修改</p><p>public final double age &#x3D; 10.0</p></li><li><p>比如在一个类的一个方法里定义的一个局部变量不想被修改</p><p>final double NUM &#x3D; 0.01 (一般不能被改变的变量名全大写)</p></li></ol><p>Note：</p><ol><li><p>变量名一般全部大写，中间用下划线隔开 TAX_NUM</p></li><li><p>一般在定义的时候就要直接赋值，或再构造器里赋值，因为final写在定义的时候，直接赋值以后就不改变了</p></li><li><p>如果写final的变量或方法是静态的，则初始化的时候不能再构造器中，可以在静态代码块中赋值</p><p>因为构造器是创建对象new的时候才会使用构造器，所以有可能就不创建对象，而final要求必须再定义的时候就要给值，这时可能还没有new，所以就会矛盾，而写在代码块中，因为代码块和静态初始胡变量一样都在类加载的时候就会执行，所以不管有没有new对象，定义是静态的，代码块也是静态的，就可以直接赋值</p></li><li><p>final了一个类，便不能继承，但是是可以实例化对象的</p></li><li><p>类已经是final了，方法就不需要final了</p></li><li><p>构造器不能final</p></li><li><p>**要想在类里面定义一个变量属性，但是主方法中只想调用这个属性值，不想加载类方法，就可以定义属性的时候写上public final static int n &#x3D; 500;</p><p>这时候底层会做一个优化，调用n的时候就只会输出500，不会加载这个类方法</p></li><li><p>包装类，String都是final类，都不能被继承</p></li><li><p>形参可以写成(final int x)，这样的话在方法内就不能修改x的值了</p></li></ol><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>当父类的一个方法存在的意义只是作为程序调用的入口，真正执行的是被重写的子类，而父类不知道该写什么，这时这个方法就可以称为抽象方法</p><p>可以写成：public abstract void eat() , 但是一旦方法写成抽象方法，类也必须修饰为抽象类，这里注意一旦修饰成抽象类，方法体就不能写了</p><p>Note：</p><ol><li>抽象类不能实例化，不能new</li><li>抽象类可以没有抽象方法</li><li>abstract只能修饰类和方法</li><li>抽象类本质还是类，各种成员都能有</li><li>一个子类继承了抽象类，则所有抽象方法必须在子类里得到实现(实现方法就是要有同名方法的方法体)，或者子类也修饰成抽象的</li><li>抽象方法不能使用private，final或static，因为这些和重写违背</li></ol><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>给出一些没有实现的方法，封装到一起，到某个类使用的时候，根据具体情况将这些方法写出来</p><p>定义接口，语法：、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123; <span class="comment">//这里定义了一个接口类</span></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//方法(抽象方法且在接口中，abstract可以省略，默认实现方法要加default修饰，静态方法加static)</span></span><br><span class="line">&#125;</span><br><span class="line">class 类名 implements 接口名&#123; <span class="comment">//这里相当于手机，相机等外设</span></span><br><span class="line">自己的属性</span><br><span class="line">    自己的方法，必须实现接口的抽象方法</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以统一管理，统一方法名</p><p>举例实现，两个程序员使用同一个接口编写连接mysql和oracle数据库的代码，最后直接调用接口</p><ol><li><p>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DBInterface</span> &#123; <span class="comment">//定义了一个接口DBInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>; <span class="comment">//创建了一个抽象方法，固定了连接数据库方法的方法名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;<span class="comment">//创建了一个抽象方法，固定了断开数据库方法的方法名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第一个程序员编写连接mysql数据库的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBMySQL</span> <span class="keyword">implements</span> <span class="title class_">DBInterface</span>&#123; <span class="comment">//定义连接断开mysql的类，实现接口DBInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123; <span class="comment">//定义一个连接mysql的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MySQL已连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; <span class="comment">//定义一个断开mysql的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MySQL断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二个程序员编写连接Oracle数据库的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBOracle</span> <span class="keyword">implements</span> <span class="title class_">DBInterface</span>&#123; <span class="comment">//定义连接断开Oracle的类，实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123; <span class="comment">//定义一个连接Oracle的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle已连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; <span class="comment">//定义一个断开Oracle的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后通过接口实现统一管理自动识别输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DBMySQL</span> <span class="variable">dbMySQL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBMySQL</span>(); <span class="comment">//创建一个连接断开mysql数据库的类的对象</span></span><br><span class="line">        <span class="type">DBOracle</span> <span class="variable">dbOracle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBOracle</span>(); <span class="comment">//创建一个连接断开mysql数据库的类的对象</span></span><br><span class="line">        <span class="comment">//然后调用action方法</span></span><br><span class="line">        action(dbMySQL); <span class="comment">//将mysql对象传入action方法</span></span><br><span class="line">        action(dbOracle); <span class="comment">//将oracle对象传入action方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(DBInterface db)</span> &#123; <span class="comment">//定义一个可以统一实现功能的方法</span></span><br><span class="line">        <span class="comment">//必须是静态的，因为主方法要调用这个action方法，主方法是静态的，所以这里也必须是静态的</span></span><br><span class="line">        <span class="comment">//传入一个已经实现DBInterface接口的类</span></span><br><span class="line">        db.connect(); <span class="comment">//直接用传入的对象调用接口里面的方法</span></span><br><span class="line">        db.shutdown(); <span class="comment">//就能自动识别是哪个数据库，然后输出相应的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ol><li>接口不能实例化</li><li>接口中的方法都是public</li><li>光标放在要实现接口的类的implements上，按alt+enter快速重写方法</li><li>若类是抽象类，则可以不用实现接口的方法</li><li>一个类可以实现多个接口，但是必须把所有接口的方法都重写</li><li>接口中所有的属性都是public static final的，只写int n &#x3D; 10，实际上是public static final int n &#x3D; 10;</li><li><strong>接口名.属性名</strong>，<strong>实现接口的类名.属性名</strong>或<strong>实现接口的类的对象名.属性名</strong>来访问接口中的属性</li><li>接口不能继承类，但是可以继承别的接口，而且可以继承不止一个接口</li><li>接口和类的修饰符都只能是public或默认</li><li>接口可以实现代码解耦，即接口规范性+动态绑定机制</li><li>若一个类A继承类B同时实现接口T，而T和B都有x属性，这时要想在A中访问x(注意这里是访问，不是修改，所以和final没关系)，那么就需要明确指明访问哪个x，访问接口的，就直接<strong>T.x</strong>，访问父类B的x就直接<strong>super.x</strong></li></ol></li></ol><h4 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h4><p>不同的类实现的是一个接口，如之前的案例所示，action方法传入的参数是实现接口的类的对象，这里体现出多态</p><p>除此之外，接口类型的变量，即接口类型的引用名可以指向实现它的类的真正对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IF</span> <span class="variable">if01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>;</span><br><span class="line"><span class="type">IF</span> <span class="variable">if01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>;</span><br></pre></td></tr></table></figure><p><strong>接口多态数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Usb usb[] = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>]; <span class="comment">//接口的多态数组，长度为2</span></span><br><span class="line">usb[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Phone</span>(); <span class="comment">//这里体现多态</span></span><br><span class="line">usb[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Camera</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;&#125; <span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;&#125; <span class="comment">//定义类实现Usb接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Note：usb[i] instanceof Phone, 表示判断是不是同一个类型的对象</p><p>遍历接口的多态数组时，由于不存在继承关系，所以要想调用类自己独有的方法时，需要向下转型，将usb[i]转成Person类型，再调用特有方法，即：**(Person)usb[i].特有方法名**</p><p><strong>接口的多态传递现象</strong></p><p>首先，接口T的引用名可以指向实现自己的类A的对象，如果这个类A没有实现这个接口T，而是实现了接口G，与此同时，接口G继承了接口T，那么这时，T的引用名t就可以指向真正的A类的对象a了</p><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>在一个类的内部又定义一个类</p><p>内部类的分类：</p><p>a. 定义在外部类的局部位置上，比如方法上</p><ol><li>局部内部类，有类名</li><li>匿名内部类，没有类名</li></ol><p>b. 定义在外部类的成员位置上</p><ol><li>成员内部类，没有用static</li><li>静态内部类，用static</li></ol><p><strong>局部内部类</strong></p><ol><li><p>可以访问外部类的所有成员，包括私有的属性或方法</p></li><li><p>不能添加访问修饰符，但是可以加final</p></li><li><p>作用域：仅仅在定义它的方法内或代码块中</p></li><li><p>外部类在定义它的方法中可以创建内部类的对象，然后调用方法即可</p></li><li><p>若外部类和局部内部类的成员重名，比如说在内部类中定义了属性和外部类一样，就近原则，只会访问内部类</p><p>若要访问外部类的属性，需要Outer.this.n1，其中Outer.this就是一个对象，代表未来调用这个方法的外部类的对象</p></li></ol><p><strong>匿名内部类</strong>(需求：要创建一个类实现接口IA，但是只用一次这个类)</p><ol><li>本质还是一个类</li><li>该类没有名字，但实际上有名字，系统取的</li><li>匿名内部类同时还是一个对象</li></ol><p>语法：new 类或接口() {</p><p>​……</p><p>}；注意这里最后有一个;</p><ol start="4"><li><p>在方法中写匿名内部类：IA tiger &#x3D; new IA()，这里的&#x3D;左边表示编译类型是IA接口类型，&#x3D;右边表示实际上运行类型是匿名内部类Outer$01，由系统分配这个名字，只用一次</p></li><li><p>所以相当于是class Outer$01 implements IA，然后马上new创建了一个匿名内部类的实例对象，赋给IA接口类型的引用名tiger，这时就可以在匿名内部类中写方法，然后在Outer的定义这个内部类的方法中就可以调用了</p></li><li><p>对象名.getClass()可以返回这个对象的类的名称</p></li><li><p>匿名内部类的最后可以调用方法，{}.say(); 因为匿名内部类相当于一个对象</p></li><li><p>不能用访问修饰符</p></li><li><p>和之前一样，若外部类和匿名内部类同名，则在方法中要想访问外部类的成员，需要外部类名.this.成员</p><p>实例：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.animal_voice();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123; <span class="comment">//创建一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; <span class="comment">//创建外部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">animal_voice</span><span class="params">()</span> &#123; <span class="comment">//创建外部类的一个方法</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>() &#123; <span class="comment">//创建一个匿名内部类，使它实现IA接口，并且直接创建一个它的实例对象赋给tiger</span></span><br><span class="line">            <span class="comment">//这里相当于两步，先创建匿名内部类实现接口，再创建实例对象赋给对象名tiger</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123; <span class="comment">//在匿名内部类中重写接口的cry方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫唤。。。&quot;</span>); <span class="comment">//该方法需要被调用才能输出</span></span><br><span class="line">                <span class="comment">//且由于匿名内部类属于局部内部类，作用域只能在定义它的方法中，所以需要在animal_voice调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.cry(); <span class="comment">//调用匿名内部类的实例对象tiger的cry方法，该方法是接口方法重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是基于接口的匿名内部类</p><p>下面是基于类的匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.animal_voice();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123; <span class="comment">//创建一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123; <span class="comment">//创建一个类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>; <span class="comment">//一个抽象方法等待重写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123; <span class="comment">//创建外部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">animal_voice</span><span class="params">()</span> &#123; <span class="comment">//创建外部类的一个方法</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>() &#123; <span class="comment">//创建一个匿名内部类，使它实现IA接口，并且直接创建一个它的实例对象赋给tiger</span></span><br><span class="line">            <span class="comment">//这里相当于两步，先创建匿名内部类实现接口，再创建实例对象赋给对象名tiger</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123; <span class="comment">//在匿名内部类中重写接口的cry方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫唤。。。&quot;</span>); <span class="comment">//该方法需要被调用才能输出</span></span><br><span class="line">                <span class="comment">//且由于匿名内部类属于局部内部类，作用域只能在定义它的方法中，所以需要在animal_voice调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.cry(); <span class="comment">//调用匿名内部类的实例对象tiger的cry方法，该方法是接口方法重写</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&quot;jack&quot;</span>) &#123; <span class="comment">//创建了一个匿名内部类Outer$02且继承了Father</span></span><br><span class="line">            <span class="comment">//用父类Father类型的对象名father来接收这个匿名内部类的实例化对象</span></span><br><span class="line">            <span class="comment">//所以此时，编译类型为Father，运行类型为匿名内部类</span></span><br><span class="line">            <span class="comment">//并且会传jack给父类的构造器</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123; <span class="comment">//重写父类Father的say方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;我说话&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;我的名字是&quot;</span> + getName()); <span class="comment">//调用name</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        father.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类的使用场景1：可以将匿名内部类的实例化对象当作参数传入目标方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        action(<span class="keyword">new</span> <span class="title class_">IA</span>() &#123; <span class="comment">//真正创建一个实现IA接口的匿名内部类的对象顺便传入自己的action静态方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123; <span class="comment">//对接口cry方法的重写</span></span><br><span class="line">                System.out.println(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(IA ia)</span> &#123; <span class="comment">//静态方法，传入一个实现IA接口的匿名内部类的对象</span></span><br><span class="line">        ia.cry(); <span class="comment">//调用接口的cry方法实现重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> &#123; <span class="comment">//创建一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员内部类</strong>：定义在外部类的成员位置</p><p>用一个类代替外部类的属性，方法</p><p><em>比如用内部类代替成员方法，然后可以重新写一个方法来创建这个内部类的对象，以此可以调用内部类里的方法</em></p><p>a.外部其他类访问成员内部类：</p><ol><li>Outer.Inner inner &#x3D; outer.new Inner(); 相当于创建Inner的普通步骤的&#x3D;的左右两边各被一个Outer.</li><li>在外部类定义一个Inner类型的<em><strong>方法</strong></em>，返回一个Inner类型对象的实例，return new Inner()；然后在外部其他类中定义一个Outer.Inner类型的对象名接收Outer.<em><strong>方法</strong></em>返回的真正的对象</li></ol><p>b.成员内部类访问外部类的各个成员可以直接访问</p><p>c.外部类的其他方法要访问成员内部类就需要<em>重新写一个方法来创建这个内部类的对象，以此可以调用内部类里   的方法</em></p><p><strong>静态内部类</strong></p><p>还是定义在外部类的成员位置，但是有static修饰</p><ol><li>可以访问外部类的所有静态成员但是不能添加非静态成员</li><li>可以添加任意访问修饰符，因为它的本质就是一个成员</li><li>作用域也为整个类体</li></ol><p>外部其他类访问静态内部类的三种方式</p><p>A. 因为是静态的，所以外部其他类直接通过类名调用即可 new Outer.Inner()；</p><p>B. 编写一个方法返回静态内部类的实例对象 （return new Inner）————主方法中：Outer.方法名（）;</p><p>C. 编写一个静态的方法返回静态内部类的实例对象</p><h3 id="Java学习第十一章"><a href="#Java学习第十一章" class="headerlink" title="Java学习第十一章"></a>Java学习第十一章</h3><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>枚举属于一种同一类的对象的集合</p><p>目的是为了防止用户乱new对象，将不属于该类对象的描述强行修改</p><p>实现方式</p><p><strong>自定义枚举</strong></p><ol><li>将类的构造器私有化，防止在主方法中new</li><li>将set方法去掉，防止主方法中设置属性值，真正做到只读</li><li>在该类内部创建固定的规定的对象，这里的对象名一般都是全部大写 public static final Season SPRING &#x3D; new Season(“春天”，“温暖”); 这里注意对象要公开便于主方法访问</li><li>优化，可以加入final修饰符和static联用可以不用完成类加载</li></ol><p><strong>使用关键字enum</strong></p><ol><li>使用enum替代class</li><li>在枚举类中创建对象直接 SPRING (“春天”，“温暖”); 即可，直接常量名后跟一个实参列表与构造器对应</li><li>如果要创建多个对象，使用，间隔SPRING (“春天”，“温暖”)，WINTER (“冬天”，“温暖”)，AUTUMN (“秋天”，“温暖”); ——且这句话要写在枚举类里面的第一行，这是规定</li></ol><p>Note：</p><ol><li>用关键字enum开发一个枚举类时，实际上是继承了一个enum类</li><li>若使用的是无参构造器创建常量对象，就可以省略小括号</li><li>所以只写了SPRING, SUMMER; 这里就是省略了小括号，调用的是默认的无参构造器</li><li>若直接输出枚举对象名(即全是大写的那个)，则输出原始的enum类的to String方法，直接输出对象名SPRING</li><li>由于枚举对象是在自己的类里面创建的，因此在主方法内需要用Season.SPRING访问，静态的可以直接访问</li></ol><p>使用关键字enum时可以使用enum类的方法，因为继承关系</p><ol><li><p>首先在主方法内再用一个普通的对象名接收已经在枚举类中创建好的枚举类对象，因此不用再加new</p><p>注意这里的<em><strong>Season.SPRING</strong></em>就表示一个在枚举类里面定义的<em><strong>枚举类对象</strong></em>，将它<em><strong>赋给</strong></em>在主方法的另一个对象名spring</p></li><li><p>所以spring.name()方法表示输出枚举对象名</p></li><li><p>spring.ordinal()方法输出枚举对象的次序&#x2F;编号，从0开始的编号</p></li><li><p>Season.values()表示生成一个数组，里面存的是每一个的枚举对象，且源码中的values方法是静态的，可以直接类名调用，该方法返回一个枚举类型的数组，不是输出！</p></li></ol><p><em><strong>补充知识点，增强for循环</strong></em></p><p>for(int i : num) { &#x2F;&#x2F;这里表示每次将一个数组num里的数拿出来赋给i</p><p>​System.out.println(i)</p><p>}</p><ol start="5"><li>valueOf，将字符串转换为枚举对象，需再用一个Season类型的变量接收，因为该方法返回一个枚举类型的对象，不是输出！，Season season &#x3D; Season.valueOf(“SPRING”)，括号里的字符串必须是已经有的常量名</li><li>compareTo方法，比较两个枚举对象，这里的比较主要比较的是编号(第几个在枚举类里创建的对象，即ordinal方法返回的值)</li><li>从始至终枚举类的真正对象只创建了一次，即只有一次new，是在枚举类Season的第一行，而之后再主方法里的Season.SPRING只是一个再枚举类里面的对象名，然后在主方法中重新将另一个对象名赋给了它，本质上还是同一个对象</li><li>要想输出枚举类对象的私有属性值，只能通过重写toString方法或写一个get方法，因为枚举类对象的方法都是其父类enum的方法</li></ol><p><strong>使用enum关键字的类后面不能再extends其他类了，因为enum已经继承了enum类了</strong></p><p>但是enum类可以实现接口，甚至多个接口，Season.SPRING可以调用重写的接口的抽象方法</p><h4 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h4><p>使用Annotation需要在其前面加上@符号，有三种：</p><ol><li>@Override，重写父类方法，该注解只能用于方法</li></ol><p>如果写了Override，编译器会检查该方法是否真的重写了父类的方法，若没有构成重写，则报错，若不加Override，就不会报错，注意，源码中Override是@interface注解类型，@interface是注解类</p><p>注意，@Target称为元注解，是修饰注解的注解</p><ol start="2"><li>@Deprecated，表示某个类或方法已经过时</li></ol><p>虽然表示已经过时，但是还是可以用，只是不推荐，具体表现为调用的时候有一个中划线</p><p>可以修饰类属性包参数等，同时可以作为新旧版本的过渡</p><ol start="3"><li>@SuppressWarnings({“输入命令，比如all”})：抑制编译器警告</li></ol><p>当不希望看到警告的时候可以使用这个注解来不显示警告</p><p>这个注解的作用范围和写它的位置有关，一般放在类上</p><p>面向对象高级tips：</p><ol><li>静态的属性初始化只随着类的加载执行一次，以后就不再执行了，但是被声明成静态的这个变量会被所有这个类的对象<strong>共享</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">50</span>); <span class="comment">//传入50价格，所以以后的新对象的价格都是50，因为共享</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(); <span class="comment">//虽然无参，但是价格不再是一开始的10，而是50，因为共享一个空间，这个空间里</span></span><br><span class="line">        <span class="comment">//的值已经从10被改变成了50</span></span><br><span class="line">        System.out.println(car.to()); <span class="comment">//输出50+5</span></span><br><span class="line"></span><br><span class="line">        System.out.println(car1.to()); <span class="comment">//一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//疑问，为什么第二次创建对象的时候的price值仍然是第一个对象的值，而不是默认值</span></span><br><span class="line"><span class="comment">//因为声明为静态的属性会被所有同类的对象共享，所以如果不自己改变属性的值，这个类的所有对象的这个属性都会是这个</span></span><br><span class="line"><span class="comment">//第一次初始化的值，直到有一个对象改变它，那在它之后的所有对象使用的都是这个共享的被改变的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//静态属性价格</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">//静态属性年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">to</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price + age; <span class="comment">//输出显示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price; <span class="comment">//构造器，传入人为想改变的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price; <span class="comment">//无参构造器，因为价格已经共享，所以这句话其实没有意义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于匿名内部类的应用</span></span><br><span class="line"><span class="keyword">package</span> Chapter11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 张珂奇</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CellPhone</span> <span class="variable">cellPhone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CellPhone</span>(); <span class="comment">//创建一个外部类的实例化对象</span></span><br><span class="line"></span><br><span class="line">        System.out.println(cellPhone.testWork(<span class="keyword">new</span> <span class="title class_">Work</span>() &#123; <span class="comment">//通过这个实例化对象调用方法</span></span><br><span class="line">            <span class="comment">//传入真正的实现接口的类的对象，这个类就是匿名内部类</span></span><br><span class="line">            <span class="comment">//直接在参数列表new创建对象并且直接重写方法(匿名内部类的特点)</span></span><br><span class="line">            <span class="comment">//同时传入正常的参数，以便中间方法可以传递给cal</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">//在这里重写接口的最终方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> n + m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>; <span class="comment">//创建一个接口，定义一个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellPhone</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">testWork</span><span class="params">(Work work, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123; <span class="comment">//写一个方法传入一个接口对象(实现接口的对象)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> work.cal(n, m); </span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">//返回一个结果</span></span><br><span class="line"><span class="comment">//具体方法要重写cal方法，所以这里返回的是cal方法最终的结果</span></span><br><span class="line"><span class="comment">//这里的test方法只是一个过渡，只是将参数传进来转给cal方法，并且调用cal方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法(外部其他类) ———— 调用外部类的目标方法 ———— 用接口对象(实现接口的匿名内部类的实例化对象)调用最终方法</span></span><br><span class="line"><span class="comment">//传真正的参数和真正的匿名内部类对象是在主方法，注意这里匿名内部类实例化直接在参数列表中完成</span></span><br></pre></td></tr></table></figure><p>小结：匿名内部类使用步骤：</p><ol><li>创建接口或父类，写好抽象方法</li><li>创建中间类和中间方法，在中间方法中形参列表传入接口类型或父类类型的对象，甚至还有完成抽象方法所需的一些其他类型的参数，比如整型</li><li>在中间方法中调用父类或接口的抽象方法，甚至传入完成抽象方法所需的参数(这里的参数是后续主方法中传进来的，这里直接调用抽象方法时拿来给进去)</li><li>在主方法中创建中间类的实例化对象，调用中间方法，传入真正的参数，其中第一个参数一般为匿名内部类的真正实例化对象，即new 接口或父类名，然后直接重写抽象方法，这里是匿名内部类的核心，重写的时候也可以将随匿名内部类的对象传入而传入的实际参数用到重写的方法里面，最终输出具体结果</li></ol><p>注意事项：</p><ol><li>内部类可以自由访问外部类的一切属性，但当内外部类的属性名相同时，要访问外部类的属性需要<strong>外部类名.this.属性名</strong></li><li>一般规范内部类里面的属性名全部大写</li><li>若想在主方法中获取到成员内部类里面的方法，需要在外部类中定义一个get方法，返回一个成员内部类的实例化对象，使用主方法中直接<strong>外部类的对象名.get方法.最终目标方法</strong></li><li>若想在主方法中获取局部内部类里面的方法，需要在定义内部类的这个外部类成员方法中创建new一个局部内部类的实例化对象，然后直接<strong>局部内部类对象名.最终目标方法</strong>，最后在主方法中创建外部类实例化对象，然后调用这个成员方法即可</li></ol><h3 id="Java学习第十二章"><a href="#Java学习第十二章" class="headerlink" title="Java学习第十二章"></a>Java学习第十二章</h3><h4 id="异常exception"><a href="#异常exception" class="headerlink" title="异常exception"></a>异常exception</h4><p>如果觉得某一段代码可能会出现问题，则可以用异常处理机制保证健壮性</p><p>将目标代码块选中，输入ctrl + alt + t，选try-catch</p><p>如果进行异常处理，即使出现异常，程序可以继续执行</p><p>e.getMessage()——表示输出异常信息，更整洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> num1 / num2; <span class="comment">//这里的num2可能会为0</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123; <span class="comment">//一旦num2为0，则抛出异常，异常被捕获赋给e</span></span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常分两大类：</p><ol><li><p>Error，JVM系统内部错误，资源耗尽等严重错误</p></li><li><p>Exception，编程错误或偶然外在因素导致的一般性错误</p><p>a. 运行时异常，程序运行时发生的</p><p>b. 编译时被编译器发现的异常</p></li></ol><p>异常体系图</p><p>Throwable——Error——StackOverflowError &#x2F; OutOfMemoryError</p><p>Throwable——Exception——RuntimeException运行时异常——NullPointerException空指针异常 &#x2F; ArithmeticException算术异常 &#x2F; ArrayIndexOutOfBoundsException数组索引越界异常 &#x2F; ClassCastException类型转换异常 &#x2F; NumberFormatException数字格式异常</p><p>Exception——FileNotFoundException其中一个编译异常</p><p>Throwable实现了Serializable接口（绿色虚线），继承了父类Object（蓝色实线）</p><p>常见的运行时异常：</p><ol><li>空指针异常，程序试图在一个没有对象只有引用名的地方获取对象（对一个空的地方进行操作）</li><li>算数异常</li><li>数组下标越界异常</li><li>类型转换异常，比如向下转型的时候两个没关系的子类互相转</li><li>数字格式不正确，比如试图将中文字符串用Integer.parseInt()转成数字</li></ol><p>编译异常，操作文件数据库等等会出现编译异常</p><p><strong>异常处理机制</strong></p><p><strong>try-catch-finally</strong></p><p>其中最后的finally代码块不管try块里有没有异常，都要执行，通常将释放资源的代码放在finally</p><p>被调用的方法不想做处理，可以用throws抛出异常给调用它的方法，然后可以try-catch甚至还可以继续throws抛出给主方法，然后可以try-catch，这里也可以抛出异常给JVM，JVM会输出异常信息然后中断退出异常信息</p><p>Note：</p><ol><li><p>try中异常发生的那一行代码到catch这一行中间的代码不会执行，会直接到catch块，但是catch后面的还是会进行</p></li><li><p>try中没有异常，catch块不会执行，但是无论如何，finally代码块都会执行</p></li><li><p>可以有多个catch语句，捕获不同的异常，父类异常在后，子类在前，发生异常后，一个异常只会匹配一个catch，如果try中同时有空指针和算数，那么这两个同时被catch(Exception e)捕获；但是如果把catch(NullPointerException e)写在前面，就只会捕获空指针异常，再把catch(ArithmeticException e)写上捕获算数异常，这样就可以实现分别捕获异常，只是父类要写在后面写在前面就没有意义了，父类Exception会将异常全部捕获，无法再单独捕获</p></li><li><p>也可以只是用try-finally，这种用法目的就是为了执行finally，不管什么时候都想要执行finally，比如释放资源，但是本质没有捕获异常，发生异常仍然会崩溃，这里注意当try有异常时，finally里的内容仍然会执行</p></li><li><p>若是在一个方法中的try-catch，必须要返回一个内容，这时如果有finally，那么返回的一定是finally里面的内容！，而不是其中一个catch的。但是<em><strong>对应catch里面的内容会被执行，只是不返回结果</strong></em></p><p>总体来说步骤是：没有finally就正常return</p><p>有finally且都有return，那就先执行catch的语句，然后再执行finally的语句，最后返回finally的结果</p><p>catch有return但finally没有，先执行catch并暂存结果，然后执行finally，再回来return刚刚暂存的结果</p><p>catch没有但finally有，那就执行catch，然后执行finally，然后返回finally的结果</p></li></ol><p><strong>throws是默认采用的方法</strong></p><p>语法：方法名() throws FileNotFoundException { &#x2F;&#x2F;将FileNotFoundException异常类抛给调用这个方法的方法</p><p>}</p><p>或者是throws这个异常类FileNotFoundException的父类Exception给到调用它的方法，而且throws后可以跟多个异常子类</p><p>Note：</p><ol><li>对于编译异常，程序中必须处理，默认处理是throws</li><li>子类throws的异常类型必须是父类throws的异常类型的子类，或者一样</li><li>如果被调用的方法throws了一个编译异常，而调用它的方法没有做任何处理，则编译不通过，需要再调用它的方法后面也写上throws 异常类型，如果是运行异常则不用写，会有默认</li></ol><p><strong>自定义异常</strong></p><ol><li>定义一个类(自己写)，继承运行异常或编译异常，一般是继承运行异常类，因为有默认处理机制</li><li>写一个构造器传入提示信息字符串形参，然后用super()将这个字符串给到父类异常类，即运行异常类，然后会一直super到Throwable类，然后输出提示信息</li><li>主方法若不满足给定条件(用if)，则throw new一个新的自定义异常类对象传入真正提示信息，通过throw抛给调用者</li></ol><p>throws和throw：</p><p>throws可以理解为一个声明，表示将这个异常抛给调用者</p><p>throw是手动生成异常类对象的一个关键字，手动生成的不一定得是自定义的异常类</p><p><strong>Note：</strong></p><ol><li>如果有finally，则在try中优先执行普通代码，如果遇到返回return，则需要先执行finally里面的内容</li><li>在try中throw出一个新的new的异常类给到调用者，而调用者正好也在一个try中，则抛出的这个异常会被catch捕捉到，如果有e.getMessage，则会输出new的时候传入的那个提示信息</li></ol><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从命令行输入两个数，调用方法相除，要求写三个异常处理，格式，命令行字符串个数，算数异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(args.length != <span class="number">2</span>) &#123; <span class="comment">//检测输入的是不是两位的一个数组</span></span><br><span class="line">                <span class="comment">//若不是，则手动抛出一个异常，这里手动是因为没法一开始就控制args数组的长度</span></span><br><span class="line">                <span class="comment">//所以需要手动判断长度是不是2</span></span><br><span class="line">                <span class="comment">//因为是手动判断，所以扔出一个什么类型的异常都可以，但是catch里要对应</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;输入不是两个数字&quot;</span>); <span class="comment">//扔出异常类对象给出信息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]); <span class="comment">//将命令行输入的字符转换成整数型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]); <span class="comment">//这里有可能会出错，按快捷键会自动catch到异常类型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cal(num1, num2); <span class="comment">//调用方法并接收算完的结果，其中调用方法可能会出现异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;计算结果为&quot;</span> + res); <span class="comment">//若一切正常代码才会来到这里</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">//和上面手动抛出的异常相对应，才能接收异常</span></span><br><span class="line">            System.out.println(e.getMessage());; <span class="comment">//输出当时传入的信息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123; <span class="comment">//自动识别的异常类型为数字格式异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是整数&quot;</span>);; <span class="comment">//给出提示信息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123; <span class="comment">//这里因为事先知道可能分母会为0，所以写上算数异常来</span></span><br><span class="line">            <span class="comment">//来接收可能抛来的异常，因为try调用了那个算术方法，所以异常会抛给try里面的调用的那个语句</span></span><br><span class="line">            <span class="comment">//然后这里识别到异常类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;分母不能为0&quot;</span>); <span class="comment">//最后打印提示信息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span> &#123; <span class="comment">//写除法发方法</span></span><br><span class="line">            <span class="keyword">return</span> n1 / n2; <span class="comment">//返回一个除完的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java学习第十三章"><a href="#Java学习第十三章" class="headerlink" title="Java学习第十三章"></a>Java学习第十三章</h3><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><p>包装类Wrapper：针对八种基本数据类型相应的引用类型——包装类 </p><p>包装类和基本数据类型转换，比如Integer和int，其中基本数据类型到包装类是装箱，反之是拆箱</p><p>JDK5之后是自动装箱了，Integer.valueOf()</p><p>手动装箱：Integer integer &#x3D; new Integer(n); </p><p>或&#x3D;Integer.valueOf(n);  一般是这个，valueOf方法传入一个整型，最后返回的就是new Integer</p><p>手动拆箱：</p><p>int i &#x3D; Integer.intValue(); 这里的intValue也是一个方法</p><p>JDK5之后自动装拆箱</p><p>Integer integer &#x3D; n;——自动装箱，底层用的还是Integer.valueOf(n)，这里要注意n的范围，如果是-128-127，那么返回的就是它本身，如果不在这个范围，那么返回的就是一个new的Integer，<strong>可参见valueOf源码</strong></p><p>int n &#x3D; Integer;——自动拆箱，底层用的还是intValue()方法</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="literal">true</span>? <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>) : <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">2.0</span>); <span class="comment">//这里是三元运算符</span></span><br><span class="line">System.out.println(obj1); <span class="comment">//这里输出不是1，而是1.0</span></span><br><span class="line"><span class="comment">//因为当三元运算符存在时，运算的时候要把三元运算符看作是一个整体，整体变为精度最高的那一个，为double</span></span><br></pre></td></tr></table></figure><p><strong>包装类和String类的相互转换</strong></p><p>Integer i &#x3D; 100；&#x2F;&#x2F;这里表示创建了一个值为100的Integer类的对象</p><ol><li>直接String str &#x3D; i + “”; 但是这样只是将i的值变成字符串重新赋给一个新的变量，不改变i自身的值</li><li>直接String str &#x3D; i.toString(); 每个类都有toString方法，这里通过Integer类的对象i调用Integer方法</li><li>直接String str &#x3D; String.valueOf(i); &#x2F;&#x2F;valueOf要求传入一个对象，然后这个方法将它转成String类型</li></ol><p><strong>将String类转成包装类</strong>，String str &#x3D; “123”;</p><p>Integer i1 &#x3D; Integer.parseInt(str);</p><p>Integer i1 &#x3D; new Integer(str); 利用Integer类里面的构造器，构造器里面其实就是parseInt方法</p><p>Note：</p><ol><li>只要有基本数据类型参与判断&#x3D;&#x3D;，则&#x3D;&#x3D;判断的就是<strong>值</strong>的大小是否相等</li><li>而如果是两个对象&#x3D;&#x3D;，则判断的是两个对象是不是同一个对象</li></ol><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><p>String类实现的接口</p><p>Serializable，String对象可以串行化，可以在网络上传输</p><p>Comparable，说明String对象可以相互比较</p><p>一个字符占两个字节，字母汉字都是</p><p>String类有很多构造器，构造器重载</p><p>String是一个final类，不能被其他类继承</p><p>String里有一个属性private final char value[]; ——表示存储字符的数组，final类型，赋值后就不能修改了，这里指的是地址不能修改，即这个value不能指向新的数组，但是单个元素字符是可以修改的</p><p><strong>String对象的创建方式</strong></p><ol><li>String str &#x3D; “……”;</li><li>通过构造器：String str &#x3D; new String(“……”);</li></ol><p>Note:</p><ol><li><p>equals方法比较的是值一不一样</p></li><li><p>&#x3D;&#x3D;比较的还是具体的实例化对象指向的是谁，即比较对象名指向的地址，有可能指向堆，也可能直接指向常量池，指向堆意味着new了一个新的String对象，指向常量池意味着直接赋值，String str &#x3D; “hhh”;</p><p>若后续用&#x3D;&#x3D;比较，则看指向的是不是同一个地方</p></li><li><p>intern()方法，返回的是常量池中值的地址，这个值和调用方法的字符串对象的值一样，如果买找到，则将该值添加到常量池中，再返回地址</p></li><li><p>若是判断一个类的name属性 &#x3D;&#x3D; “zkq”; 则判断的也是地址，这里注意，因为name属性已经赋值为”zkq”，且字符串常量在&#x3D;&#x3D;比较中直接给出的就是在常量池中的地址，所以这里是ture的</p></li><li><p>注意字符串是final类，说明其在常量池中的那个字符串值不能被直接替换成新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">//创建一个字符串对象直接指向常量池中的&quot;Hello&quot;，则Hello不能被替换掉(一直在)</span></span><br><span class="line">s1 = <span class="string">&quot;haha&quot;</span>; <span class="comment">//这里其实也创建了一个字符串对象，因为常量池中没有&quot;haha&quot;，所以要创建</span></span><br></pre></td></tr></table></figure></li><li><p>编译器遇到”hello” + “abc”，会自动优化成”helloabc”，合二为一</p></li><li><p>若遇到String c &#x3D; a + b; 系统会创建StringBuilder类的对象来调用里面的方法</p><p>先调用append方法把一个空的数组里面加上了a字符串对象的值，再调用一次加上b字符串对象的值</p><p>然后String c &#x3D; a + b，由于&#x3D;右边不是具体的常量值，所以这里再底层有一句：String c &#x3D; sb.toString()，sb是StringBuilder的对象名，而toString方法会返回一个new，这就表示再在堆中新开了一块空间，c指向这个空间，空间内是”helloabc”在常量池中的地址</p><p>但是如果是(a + b).inter(); ——就指向的是池中的字符串常量</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">meiju</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">meiju</span>(); <span class="comment">//创建一个本类的对象，在栈中创建一个ex引用名，指向堆中的str和ch</span></span><br><span class="line">        ex.change(ex.str, ex.ch); <span class="comment">//调用change方法，传入自己的两个属性</span></span><br><span class="line">        System.out.println(ex.str); <span class="comment">//虽然change方法改变了str的值，但是由于String类型是final的</span></span><br><span class="line">        <span class="comment">//无法改变自身属性，所以调用方法时在栈中新开一个空间，里面的str直接指向&quot;java&quot;</span></span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">        <span class="comment">//这里不一样，新栈中的ch指向的是堆中原来的ch，并且改变了它的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;zkq&quot;</span>); <span class="comment">//因为是在类中定义一个字符串的对象，所以这里在底层</span></span><br><span class="line">    <span class="comment">//是在堆中创建了一个value指向池中的&quot;zkq&quot;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">char</span> ch[] = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;; <span class="comment">//字符类型属于基本数据类型，所以这里就是在堆中产生字符数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123; <span class="comment">//定义一个方法用来改变两个属性的值</span></span><br><span class="line">        str = <span class="string">&quot;java&quot;</span>; <span class="comment">//根据字符串的用法，这里=右边直接就是一个常量&quot;java&quot;</span></span><br><span class="line">        <span class="comment">//所以这里会在栈中重新开一块空间直接指向池中的&quot;java&quot;</span></span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>; <span class="comment">//虽然是final，但是不影响改变它里面的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>字符串常用方法</strong></p><p>str.substring(6)表示从字符串的第六位开始，截取后面的字符串</p><p>str.substring(0, 5)表示从字符串的第0位开始，截取到第5-1&#x3D;4位</p><p>str.concat(“zkq”)表示将zkq拼接到str字符串的后面</p><p>str.replace(“a”, “b”)，将所有的a替换成b</p><p>注意以上这些方法都需要有一个字符串变量名来接收结果，但是原来的str并没有变化</p><p>str.split(“,”); 以，为标准进行分割，分割后的结果返回一个数组，这里需要一个数组变量名来接收</p><p>注意这里要想用&#x2F;&#x2F;分割，需要写成&#x2F;&#x2F;&#x2F;&#x2F;，转义字符</p><p>str.toCharArray(); 表示将str转成字符数组，每一个字符都分开，也需要一个字符变量名来接收</p><p>a.compareTo(b)，一个一个字符的比，直到两个对应字符不一样，那就前面的那个的数值编码减后面的字符编码，若每个字符都一样，且发现两个字符串的长度不一样，则用前面的长度减去后面的长度</p><p><em><strong>字符串格式，String.format(“%s  %d  %.2f  %c”, name, age, score, gender)会自动对应填到相应的占位符上且可以将”%s  %d  %.2f  %c”赋给一个字符串变量，后续可以直接使用变量名，复用性高</strong></em></p><p>%d表示整数</p><p><strong>StringBuffer类</strong></p><p>这个里面的属性不是final类型的，但是它本身是final类的，不能被继承</p><p>StringBuffer对象可以串行化</p><p>在它的父类中有一个不是final类型的属性value，所以它的value数组存放在堆中，而不是常量池，且长度可变(初始化为16)当value数组容量不够的时候才会更新地址，重新在堆中开一个数组，再让value指向它，这样效率比String高，不用每次都创建新对象指向常量池</p><p>属性value数组的长度默认为16，同时创建Buffer对象的时候可以构造器指定value长度，直接括号中写长度</p><p>若传入的是一个字符串，则默认value为传入的字符串，且长度为传入字符串的长度加16</p><p><strong>String转StringBuffer</strong></p><p>同上，先创建一个String字符串，然后将其赋给str，再将str传入创建Buffer时候的构造器</p><p>或者使用sb.append(str)，然后用Buffer对象名接收</p><p><strong>StringBuffer转String</strong></p><p>使用Buffer提供的toString方法</p><p>或者使用构造器，将sb传入创建String对象的构造器</p><p><strong>Buffer常用方法</strong></p><p>insert方法</p><p><strong>StringBuilder类</strong></p><p>单线程使用这个，因为它存在多线程安全问题</p><p>它也能串行化，网络传输或保存在文件中</p><p>也是final类，也不能被继承</p><p>其对象的字符序列一依然是存放在父类的属性字符char[] value中，也是在堆中</p><p>Builder的方法都没有做互斥处理，即没有synchronized关键字，因此在单线程使用它</p><p><strong>对比三个String类</strong></p><p>String不可变序列效率低(每次都要重新创建一个新的字符串对象)，但是每个新的字符串对象都指向同一个池中的”zkq”，有zkq的话就不会在池重重新创建一个zkq</p><p>StringBuffer可变序列，增删改查效率高，且线程安全</p><p>StringBuilder可变序列效率最高，但是存在线程安全的问题</p><p><strong>结论</strong></p><ol><li>如果要对字符串做大量的修改工作，就使用Buffer或Builder</li><li>存在大量修改工作且在单线程的情况，使用Bulider</li><li>存在大量修改工作且在多线程，使用Buffer</li><li>修改工作很少，且字符串被多个对象引用，使用String，比如配置信息</li><li>注意Buffer和Builder的方法使用一样</li></ol><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><p>静态的，直接用类名操作</p><p>abs绝对值</p><p>pow(2，4)，2的四次方</p><p>ceil向上取整，返回大于等于给定值的最小整数，然后转成double</p><p>floor向下取整</p><p>round四舍五入</p><p>random方法，返回一个0闭到1开之间随机的一个小数，所以要取自定义两个数之间的随机数比如2-7</p><p>就需要(int)(a + Math.random() * (b - a + 1))</p><p>其中Math.random() * (b - a + 1)的值最大是5.99999，再加上前面的2，就是7.99999，再取整正好就是7，OK</p><p>最小是0，0再加2就是2，OK</p><p>+1是为了能取到7</p><p>Math.max(a,b)返回a和b其中的最大值</p><h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>有这个类就不用再遍历数组输出了</p><p>直接Arrays.toString(arr)，将arr数组里面的内容拼接到了一个字符串中，前后各加一个[]</p><p><strong>sort方法使用</strong></p><p>给定一个数组，直接调用Arrays的sort方法排序</p><p>若要自定义排序的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubble(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123; <span class="comment">//调用自己写的bubble静态方法</span></span><br><span class="line">            <span class="comment">//传入arr数组和真正的实现了Comparator接口的匿名内部类的对象并且直接重写compare方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123; <span class="comment">//这里的形参是Object类的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> (Integer)o1; <span class="comment">//所以需要将他们向下转型成Integer类的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> (Integer)o2; <span class="comment">//然后在拆箱赋给int型变量</span></span><br><span class="line">                <span class="keyword">return</span> n1 - n2; <span class="comment">//这里的结果决定了在bubble方法中的if判断语句怎么判断升序还是降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span> arr[], Comparator c)</span> &#123; <span class="comment">//定义一个冒泡方法，传入整型数组和</span></span><br><span class="line">        <span class="comment">//和一个实现了接口的匿名内部类的对象形参</span></span><br><span class="line">        <span class="comment">//下面是具体冒泡排序的步骤</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(arr[j], arr[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于数组是引用类型，所以修改完成后本身就会被修改，不用再赋值给其他变量名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找：必须是有序的数组，binarySearch，如果不存在该数，则返回这个数应该在的下标位置+1，再取负数</p><p>int newArr[] &#x3D; Arrarys.copyOf(arr, arr.length)表示将arr的arr.length个元素拷贝给新数组newArr</p><p>若将一个负数个元素拷贝，则抛出异常</p><p>Arrays.fill(arr, 5)表示用5替换arr里面的所有元素</p><p>asList方法会将数据转成一个集合</p><p>案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建四本书，并通过Arrays方法和价格进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Book book[] = <span class="keyword">new</span> <span class="title class_">Book</span>[<span class="number">4</span>]; <span class="comment">//创建一个Book类的数组存放Book类的对象</span></span><br><span class="line">        book[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="number">100</span>); <span class="comment">//参数传入构造器，价格是double类型</span></span><br><span class="line">        book[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;金瓶梅&quot;</span>, <span class="number">90</span>);</span><br><span class="line">        book[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;青年文摘&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        book[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;JAVA&quot;</span>, <span class="number">300</span>);</span><br><span class="line">        Arrays.sort(book, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123; <span class="comment">//调用Arrays的sort定制排序方法，传入book类对象</span></span><br><span class="line">            <span class="comment">//和一个实现了Comparator接口的匿名内部类对象，并·直接重写compare方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123; </span><br><span class="line">                <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> (Book)o1; <span class="comment">//将o1o2转成Book类型</span></span><br><span class="line">                <span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> (Book)o2; <span class="comment">//才能调用getPrice方法</span></span><br><span class="line">                <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> book1.getPrice() - book2.getPrice(); <span class="comment">//因为compare方法返回整数</span></span><br><span class="line">                <span class="comment">//所以这里需要手动返回整数</span></span><br><span class="line">                <span class="keyword">if</span>(res &lt; <span class="number">0</span>) &#123; <span class="comment">//判断两个price相减的数的大小</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//手动返回整数</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(book));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><p>arraycopy和之前的Arrays.copyOf一样，其实copyOf底层会找到System.arraycopy，也是复制元素</p><p>System.exit(0) 表示退出程序</p><p>System.arraycopy(src, 0, dest, 0, 3);</p><p>src是源数组，被拷贝数组</p><p>第二个位置是srcPos，表示从源数组的哪一个索引开始拷贝</p><p>第三个位置是dest表示目标数组，把源数组的数据拷贝到哪个数组</p><p>第四个位置destPos表示拷贝到目标数组的哪个索引</p><p>最后一个是length，从源数组拷贝多少个数据到目标数组</p><p>currentTimeMillens返回当前的秒数，自1970年1月1日，毫秒</p><h4 id="BigInteger和BigDecimal类"><a href="#BigInteger和BigDecimal类" class="headerlink" title="BigInteger和BigDecimal类"></a>BigInteger和BigDecimal类</h4><p>当编程中需要处理一个很大的整数，long不够用的时候，就用BigInteger类，传数据的时候可以传成字符串的形式</p><p>运算的时候需要用这个类自己的方法，比如add，不能直接+-*&#x2F;</p><p>两个加数都搞成BigInteger类，然后BigInteger b &#x3D; b1.add(b2); 相当于b1 + b2，然后赋给b</p><p>BigDecimal也和Integer一样，可以小数点后无限</p><p>也不能使用+-*&#x2F;</p><p>若除的时候结果是无限循环小数，则可以加b1.divide(b2, BigDecimal.Round_CEILING) ，来保留分子的精度(长度)</p><h4 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h4><p>Date：精确的毫秒，代表特定的瞬间</p><p>SimpleDateFormat：将日期规范化</p><ol><li><p>Date的无参构造器就是获取当前时间</p></li><li><p>所以创建Date对象的时候就获取了时间</p></li><li><p>默认输出是默认格式，需要对其进行转换</p></li><li><p>可以将一个已经格式化好的日期字符串转换成Date</p><p>但是这里得到的Date仍然是国外的形式</p></li><li><p>用法，sdf.format(date)得到格式化好的日期</p></li><li><p>用法，sdf.parse(s)得到默认格式的字符串里转化而来的日期，s是字符串里写着日期</p></li></ol><p><strong>第二代，Calendar</strong></p><p>Calendar()也有无参构造器，但是它是私有的，所以它调用的是一个getInstance</p><p>获取Calendar对象的某个日历字段</p><p>需要Calendar c &#x3D; Calendar.getInstance()</p><p>然后c.get(Calendar.YEAR) 或 c.get(Calendar.MONTH) + 1——这里加一是因为月是从0开始取的</p><p>Calendar需要程序员自己排列组合</p><p><strong>第三代日期</strong></p><p>calendar的问题：</p><ol><li>不是线程安全的</li><li>不能处理闰秒（每隔两天多出1s）</li><li>日期和时间这样的类应该是不可变的，而它是可变的</li><li>date中的年份是从1900开始的，月份都是从0开始</li><li>没有格式化</li></ol><p>所以第三代日期：</p><p>LocalDate(日期，年月日)</p><p>LocalTime(时间，时分秒)</p><p>LocalDateTime(日期时间，年月日时分秒)，一般是用这个</p><p>可以使用now()方法获取当前时间，使用对象.getYear，对象.getMonth等获取年月</p><p>注意这里的getMonthValue是返回阿拉伯数字月份</p><p>如果要定制格式输出，需要DateTimeFormatter类</p><p>创建其对象，直接DateTimeFormatter.ofPattern（”yyyy年MM月dd日 HH小时mm分钟ss秒”）</p><p>然后用DateTimeFormatter类的对象名dateTimeFormatter接收</p><p>然后将LocalDateTime的对象ldt放入dateTimeFormatter.format(ldt)即可</p><p>可以用一个String接收，也可以直接输出dateTimeFormatter.format(ldt)</p><p><strong>instant时间戳</strong></p><p>时间戳本质也是获取时间，但是精度很高到纳秒，具体指格林威治时间1970年1月1日0时0分0秒到现在的总秒数</p><p>instant和date相互转换</p><p>用静态方法创建时间戳对象Instance now &#x3D; Instance.now();</p><p>然后通过from将Instance转换为Date，Date date &#x3D; Date.from(now);</p><p>而通过Date的date.toInstance()方法可以将Date对象转换为Instance对象</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcdefghijk&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//传入起始，结束，字符串对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s1 = exchange(<span class="number">1</span>, <span class="number">1</span>, s); <span class="comment">//传入参数，起始结束和字符串对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//捕获到运行异常，输出异常信息，return结束程序</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回一个新的字符串对象，所以这里用一个字符串对象名接收</span></span><br><span class="line">        System.out.println(s1); <span class="comment">//输出字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">exchange</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String s)</span> &#123; <span class="comment">//编写方法</span></span><br><span class="line">        <span class="comment">//加一个对于输入参数的验证</span></span><br><span class="line">        <span class="keyword">if</span>(!(s != <span class="literal">null</span> &amp;&amp; start &gt; <span class="number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; start &lt; end)) &#123; <span class="comment">//这里先写正确的情况</span></span><br><span class="line">            <span class="comment">//然后取反，这样效率高</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;参数不正确&quot;</span>); <span class="comment">//抛出new一个运行异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> c[] = s.toCharArray(); <span class="comment">//将传入的字符串转换为一个字符数组</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>; <span class="comment">//临时字符变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++, j--) &#123; <span class="comment">//两个索引一起运动，当到一般的时候也就是</span></span><br><span class="line">            <span class="comment">//i&lt;j的时候就停止</span></span><br><span class="line">            temp = c[i]; <span class="comment">//交换</span></span><br><span class="line">            c[i] = c[j];</span><br><span class="line">            c[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c); <span class="comment">//重新创建一个字符串对象将修改好的c传入构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：</p><ol><li><p>intern方法返回的就是常量池中字符串值的地址</p></li><li><p>看见equals方法一定要看谁调用的它，调用者有没有重写这个方法，若没有重写，则判断的还是是否是同一个对象，比如String类里面就重写了equals方法，比较的就是值</p></li><li><p>字符串赋值的时候&#x3D;右边是常量加变量的形式，则底层会调用StringBuilder的append方法，再常量池中把给定的常量和变量对应的哪个值拼接起来，然后堆中重新开一个value指向常量池中拼接好的值，最后创建中国字符串对象时，再栈中创建一个str引用名指向堆中的value</p></li><li><p>用%s%c这些一定是format方法，即String.format</p></li></ol><h3 id="Java学习第十四章"><a href="#Java学习第十四章" class="headerlink" title="Java学习第十四章"></a>Java学习第十四章</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>数组的不足:</p><ol><li>长度必须一开始就指定而且不能修改</li><li>数组保存的必须是同一类型的元素</li><li>使用数组增加元素的时候比较麻烦</li></ol><p><strong>集合</strong></p><ol><li>可以动态保存任意多个元素，可以不同类型</li><li>增删改查方便</li></ol><h4 id="集合体系图"><a href="#集合体系图" class="headerlink" title="集合体系图"></a>集合体系图</h4><p>单列集合：</p><p>ArrayList &#x2F; Vector &#x2F; LinkedList —— List —— Collection —— Iterable</p><p>TreeSet &#x2F; HashSet —— Set—— Collection —— Iterable</p><p>双列集合：(键值对)</p><p>Properties ——继承——List —— Map</p><p>LinkedHashMap ——继承——HashMap —— Map</p><p>TreeMap —— Map</p><p>注意——表示实现接口</p><p><strong>各种ArrayList的方法</strong></p><p>略</p><p><strong>Collection接口和常用的方法</strong></p><p>遍历Collection接口的方式为迭代器Iterator方法，首字母是i</p><p>实现Collection接口的集合类都有iterator方法，返回一个实现了Iterator接口的对象，即迭代器</p><p>Iterator仅遍历集合，不存放数据</p><p>用法：iterator.next()，注意iterator有个方法为iterator.Next()来判断下面还有没有数据了，没有就返回false</p><p>next()的作用两个：1下移，2将下移以后集合位置上的元素返回(先下移，再返回)</p><p>注意用next之前必须要先用hasNext判断下一个位置有没有元素，因为next直接就要下移</p><p>next返回下一个元素返回来的是Object元素</p><p>即遍历的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator(); <span class="comment">//调用迭代器方法，返回一个迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123; <span class="comment">//hasNext方法判断有没有下一个元素</span></span><br><span class="line">            System.out.println(iterator.next()); <span class="comment">//下移，然后返回具体的元素</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next(); <span class="comment">//这里默认返回的是Object类的元素</span></span><br><span class="line">            <span class="comment">//但是它的运行类型是元素本身的类型</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//以上代码通过itit回车快速生成</span></span><br></pre></td></tr></table></figure><p>注意当退出while循环后，游标(指针)在最后一个位置，所以这时不能再用iterator.next()，否则抛出异常NoSuchElementException</p><p>所以需要重置迭代器(再重新用集合对象调用迭代器方法再返回一个新的迭代器对象重新赋给原来的迭代器)</p><p>即iterator &#x3D; arrayList.iterator();</p><p><strong>增强for循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object book : arrayList) &#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也能再数组使用，增强for底层仍然是迭代器，是简化版迭代器，快捷方式大写i</p><p>两个Collection子接口<strong>List接口</strong></p><ol><li>List子接口的元素存进去以后的取出元素的顺序和添加的顺序一样，而且可以重复</li><li>每个元素有索引，从0开始，所以get(索引)可以取出元素</li></ol><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p><strong>List接口的常用方法</strong></p><p>add可以指定再哪个位置插入什么元素add(1, “hhh”); 若不加索引，则默认最后</p><p>addAll(1, list2)；将list2里面的所有元素再list1的1的位置全插进去</p><p>remove(2)；移除指定位置的元素</p><p>set(2, “jkj”)；相当于将原先索引为2的位置的元素替换成”jkj”</p><p>List newList &#x3D; list.subList(0, 2)；将list的下标从0到2的元素取出赋给newList，注意前闭后开</p><p>list的长度为list.size()</p><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>, <span class="number">105</span>, <span class="string">&quot;曹雪芹&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>, <span class="number">99</span>, <span class="string">&quot;罗贯中&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;小李飞刀&quot;</span>, <span class="number">15</span>, <span class="string">&quot;古龙&quot;</span>));</span><br><span class="line">        bubble(list); <span class="comment">//直接调用冒泡排序方法，不用接收，因为集合是引用类型，所以谁修改它都会变化</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(List list)</span> &#123; <span class="comment">//这里void即可，集合是引用类型，方法里改变就会保存</span></span><br><span class="line">        <span class="comment">//集合排序注意不能直接调用元素对象的方法或属性</span></span><br><span class="line">        <span class="comment">//应该取出元素后向下转型赋给具体的对象引用名</span></span><br><span class="line">        <span class="comment">//然后用赋值后的引用名来调用getPrice方法获取价格，然后进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123; <span class="comment">//注意集合长度是size()</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; list.size() - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> (Book)list.get(j); <span class="comment">//取出集合元素向下转型成Book类型</span></span><br><span class="line">                <span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> (Book)list.get(j + <span class="number">1</span>); <span class="comment">//用Book类型的引用名book接收</span></span><br><span class="line">                <span class="keyword">if</span>(book1.getPrice() &gt; book2.getPrice()) &#123; <span class="comment">//用book引用名调用get方法获取价格比较</span></span><br><span class="line">                    list.set(j, book2); <span class="comment">//集合元素的交换直接用set方法替换即可</span></span><br><span class="line">                    list.set(j + <span class="number">1</span>, book1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, <span class="type">double</span> price, String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&quot;, author=&#x27;&quot;</span> + author + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ol><li>空元素也可以放到集合ArrayList中</li><li>ArrayList底层是由数组来实现</li><li>再多线程情况下，不建议使用ArrayList，可以使用Vector</li></ol><p><strong>ArrayList底层操作机制</strong></p><ol><li>ArrayList底层维护的是一个Object类型的elementData数组，这个数组是ArrayList类的属性</li><li>创建ArrayList对象时，若使用的是无参构造器，则初始elementData容量为0，第一次添加元素则扩容为10，第二次为1.5*10，即1.5倍</li><li>若使用指定大小的构造器，这时需要扩容的时候就直接扩1.5倍，Vector是2倍扩容</li><li>若一个属性被transient修饰，则说明其不能被序列化</li></ol><p><strong>LinkedList</strong></p><p>它的底层实现了双向链表和双端队列特点</p><p>可以添加任意元素，包括null</p><p>线程不安全，没有实现同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">hsp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;hsp&quot;</span>);</span><br><span class="line">        jack.next = tom; <span class="comment">//依次通过next指向下一个对象</span></span><br><span class="line">        tom.next = hsp;</span><br><span class="line"></span><br><span class="line">        hsp.pre = tom; <span class="comment">//依次通过pre指向上一个对象</span></span><br><span class="line">        tom.pre = jack;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> jack; <span class="comment">//双向链表的头结点，让它指向第一个对象jack</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> hsp; <span class="comment">//双向链表的尾结点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">smith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;smith&quot;</span>); <span class="comment">//添加一个新的结点对象</span></span><br><span class="line">        tom.next = smith; <span class="comment">//将前面的next重新指向smith</span></span><br><span class="line">        smith.next = hsp; <span class="comment">//然后smith的next指向hsp</span></span><br><span class="line"></span><br><span class="line">        hsp.pre = smith; <span class="comment">//同理</span></span><br><span class="line">        smith.pre = tom;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//实际上first就是一个对象索引，不断被jack tom等对象赋值</span></span><br><span class="line">            <span class="keyword">if</span>(first == <span class="literal">null</span>) &#123; <span class="comment">//因为next到最后一个的时候，再往下走会变为null，使用这时就终止</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(first); <span class="comment">//输出当前对象，也就是first</span></span><br><span class="line">                first = first.next; <span class="comment">//让它自己等于它的next指向的对象</span></span><br><span class="line">                <span class="comment">//因为之前已经定义过每个结点的关系了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node pre;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> Object item;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.item = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node name = &quot;</span> + item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CRUD增删改查</p><p>关于LinkedList的方法</p><p>看源码</p><p><strong>ArrayList和LinkedList对比</strong></p><p>Array底层结构为可变数组，Link为双向链表</p><p>增删的效率A较低，L增删效率高，直接通过链表追加</p><p>改查A效率高，L效率低，一般来说都是改查，所以A用的多，也可以不同项目分情况使用</p><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>HashSet和TreeSet</p><p>Set接口：</p><ol><li>无序的，添加和取出的顺序不一样，且没有索引，但是每次取出(重新运行)的顺序是一致的</li><li>不允许重复数值，最多包含一个null</li><li>Collection接口的方法，Set也有</li><li>遍历时不能使用索引，可以用迭代器和增强for</li></ol><p><strong>HashSet</strong></p><ol><li><p>实现了Set接口</p></li><li><p>HashSet实际上是HashMap</p></li><li><p>add方法会返回一个布尔值，添加成功返回T，失败返回F，若已经有这个元素了，再去添加则会返回F，添加失败</p></li><li><p>HashSet元素不能是同一个对象，但是如果元素是new一个类，即使传入的参数相同，那也可以共存(不同对象)</p></li><li><p>补充4：add底层到底是哪个对象不能相同，常量池还是堆中的对象</p></li></ol><p>HashSet的底层是HashMap，即数组+链表+红黑树</p><p><strong>LinkedHashSet</strong></p><p>数组+双向链表</p><p>取出的数据与添加数据顺序是相同的</p><h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><ol><li>Map与Collection没关系，两大类，Map用于保存映射关系的数据，Key-Value(双列元素)</li><li>数据会封装在静态内部类$Node中</li><li>Key一样的话会做一个替换，值替换值</li><li>若Key不一样，值一样则不影响，是可以重复的</li><li>Key和值都能为null，但是Key只能一个null，而值value可以重复null</li><li>常用字符串作为Key</li><li>Key和value是单向对应关系  map.get(传入一个Key)，返回一个对应的value</li><li>一对Key-Value是放在一个HashMap$Node中的，因为Node实现了Entry接口，一对k-v就是一个Entry</li><li>Entry是为了程序员遍历方便，Entry是EntrySet里面的元素类型，而EntrySet里面元素定义类型是Map.Entry，因为要用Entry的方法但实际上是Node，实际运行类型其实还是Node</li><li>因为Node实现了Entry，所以可以向上转型这样定义</li><li>当把HashMap$Node对象存放到entrySet就方便遍历，向上转型因为Map.Entry提供了getKey和getValue</li><li>Entry是Map里面的静态内部类，作用是为了让调用get方法</li><li>总体来说就是将每个Node拿出来封装成一个一个的Entry，然后再将Entry作为定义类型的元素依次放到entrySet集合中</li><li>但是实际上并没有实质性的拿出来给过去，只是让每个Entry指向原来的Node</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//创建HashMap对象</span></span><br><span class="line">        map.put(<span class="string">&quot;01&quot;</span>, <span class="string">&quot;zkq&quot;</span>); <span class="comment">//放入k-v</span></span><br><span class="line">        map.put(<span class="string">&quot;02&quot;</span>, <span class="string">&quot;zyj&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;03&quot;</span>, <span class="string">&quot;yjh&quot;</span>);</span><br><span class="line">        <span class="comment">//由于HashMap不能用迭代器，所以只能将每一个k-v(也就是每一个Node)都封装成Map.Entry类的编译类型</span></span><br><span class="line">        <span class="comment">//这里实际上是Entry指向每一个Node</span></span><br><span class="line">        <span class="comment">//然后创建一个entrySet集合存放每一个Entry元素，这样就可以用迭代器遍历</span></span><br><span class="line">        <span class="comment">//编译类型搞成Map.Entry是为了底层可以调用getKey和getValue方法来输出</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.entrySet(); <span class="comment">//调用entrySet方法来创建EntrySet类的对象也就是集合</span></span><br><span class="line">        <span class="comment">//也可以Collection values = map.values();相当于只取值进行封装然后遍历</span></span><br><span class="line">        <span class="comment">//或者Set set = map.keySet();相当于只取键进行封装然后遍历，而且还能通过map.get取对应的值</span></span><br><span class="line">        <span class="comment">//将集合赋给set引用名</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : set) &#123; <span class="comment">//将每一个set的元素赋给o</span></span><br><span class="line">            <span class="comment">//这里可以直接println(o)，但是只能输出全部键值</span></span><br><span class="line">            <span class="comment">//若要单另输出键或值，则如下</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry)o; <span class="comment">//o向下转型为Map.Entry接口对象类型</span></span><br><span class="line">            <span class="comment">//这样就能调用Entry接口下的get方法获取Key和Value，最终输出</span></span><br><span class="line">            <span class="comment">//注意这里的KV实际上还是在Node里面，只不过因为Node实现了Entry接口，所以可以向上转型</span></span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Map接口的常用方法</strong></p><p>put</p><p>remove(键)——删除对应的值</p><p>根据Key返回对应的值，这里是按照对象的形式，需要Object obj &#x3D; map.get(键)，然后输出obj</p><p><strong>案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义员工类(id，name，sal)，主方法中用HashMap添加三个对象，键为id，值为员工对象，输出sal大于400的员工</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;zkq&quot;</span>, <span class="number">500</span>, <span class="number">1</span>));</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;zyj&quot;</span>, <span class="number">800</span>, <span class="number">2</span>));</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;yjh&quot;</span>, <span class="number">300</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">//        Set set = map.entrySet();</span></span><br><span class="line"><span class="comment">//        for (Object o : set) &#123;</span></span><br><span class="line"><span class="comment">//            Map.Entry m = (Map.Entry)o;</span></span><br><span class="line"><span class="comment">//            Employee employee = (Employee) m.getValue();</span></span><br><span class="line"><span class="comment">//            if(employee.getSal() &gt; 400) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(employee);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next(); <span class="comment">//定义next指针为Object类型</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry)next; <span class="comment">//将指针指向的对象转为Map.Entry类型，为了getValue</span></span><br><span class="line">            <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> (Employee)m.getValue(); <span class="comment">//getValue取出的值是Object类型</span></span><br><span class="line">            <span class="comment">//所以需要将其转成Employee类型，才能调用getSal方法</span></span><br><span class="line">            <span class="keyword">if</span>(employee.getSal() &gt; <span class="number">400</span>) &#123;</span><br><span class="line">                System.out.println(employee);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSal</span><span class="params">(<span class="type">double</span> sal)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> sal, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, sal=&quot;</span> + sal +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hashtable类</strong><br>实现了Map接口</p><p>键值都不能为null</p><p>使用方法基本和HashMap一样</p><p>线程安全</p><p>初始化的时候大小为11，加载因子0.75</p><p><strong>Properties</strong>，继承Hashtable</p><p>也是键值对保存</p><p>外部文件，Properties可以读取外部文件，然后进行一个信息的读取和修改</p><p><strong>什么时候用什么</strong></p><p>先判断要存储的类型，是单列还是双列</p><ol><li>一组对象(单列)：Collection接口</li></ol><p>允许重复：List</p><p>偏增删：LinkedList(底层是一个双向链表)</p><p>偏改查：ArrayList(底层是一个可变数组)</p><p>不允许重复：Set</p><p>无序：HashSet(底层是HashMap，维护了一个哈希表，即数组+链表+红黑树)</p><p>排序：TreeSet</p><p>插入和取出顺序一致：LinkedHashSet，维护了一个数组+双向链表</p><ol start="2"><li>一组键值对：Map</li></ol><p>键无序：HashMap(底层是哈希表，数组+链表+红黑树)</p><p>键排序：TreeMap</p><p>键插入和取出顺序一致：LinkedHashMap</p><p>读取文件：Properties</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>也是新建TreeSet对象的时候传入一个比较器comparator然后重写compare方法自定义规则(匿名内部类)</p><p>可以自定义比对两个对象(可以是字符串)的长度</p><p><strong>TreeMap</strong></p><p>是TreeSet的底层</p><p>使用默认无参构造器创建时还是无序的</p><p>若规则是字符串长度，键相同的情况下新添加的值会替换原先键的值，但是键还是之前的</p><p><strong>工具类Collection</strong></p><p>可以直接用类名调用它相应的方法，比如倒转元素顺序，reverse方法</p><p>Collections.shuffle(list)表示打乱元素顺序然后随机排序</p><p>sort按照自然顺序排序，比如按照英文字母顺序排序，也可以同时传入一个Comparator对象，重写比较compare方法</p><p>swap(list, 0, 1)表示0和1位置的元素交换位置</p><p>max返回自然排序最大的那个元素，也可以传入一个Comparator对象，重写比较compare方法，自定义什么最大的返回对象，比如可以自定义字符串长度最大，不传入比较器就是自然排序</p><p>frequency(list, “tom”)，返回tom出现的次数</p><p>copy(dest, list)，将list的内容复制到dest中，且list的大小小于等于dest，否则抛出异常</p><p>replaceAll(list, “a”, “b”)将所有a换成b</p><p><strong>Note：</strong></p><p>当用HashMap的时候是先算哈希值，如果相同才比较(程序员自定义的比较方法)但是如果添加的是一个对象，且添加完成后对这个对象的其中一个属性进行了修改，这时再传入一个和修改过后的相同值的相同对象的时候是可以添加进去的，因为原来的哈希值不变，这时添加的这个虽然内容和原先的相同，但是哈希值不一样，所以会添加成功，且添加在不同的数组的位置上</p><p>同理，添加与原先的值一样的对象，哈希值是一样的，但是内容不一样，会挂载到原先对象的后面</p><p>另外，如果要删除原先的对象，系统会找到<strong>目前</strong>这个对象的键值，然后根据键值算出哈希值，再根据哈希值定位到数组中，这时算出来的哈希值肯定和原来不一样，因为已经修改过，是系统实际上是定位到了一个空的地方，所以删除失败</p><h3 id="Java学习第十五章"><a href="#Java学习第十五章" class="headerlink" title="Java学习第十五章"></a>Java学习第十五章</h3><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>传统添加数据的时候不能对加入到集合中的数据类型进行约束(不安全)</p><p>遍历的时候会用到类型转换，若集合中不是一个数据类型，会抛异常</p><p>所以使用泛型<Dog></p><p>ArrayList<Dog> arrayList &#x3D; new ArrayList<Dog>()</p><p>这时编译器会自动约束数据类型必须是Dog</p><p>而且遍历的时候也可以直接使用Dog而不用进行类型转换</p><p>比如增强for循环</p><p>for(Dog dog ：arrayList) {</p><p>}就不用写Object</p><p>泛型可以表示一种数据类型，由程序员指定（即表示其他数据类型的数据类型）</p><p>E &#x3D; Integer &#x2F; String &#x2F; Dog</p><p>若使用泛型后编译通过，则运行时肯定不会出现类型转换异常</p><p>定义类的时候用<E>代表泛型，即再主方法中创建对象的时候可以写任意一种类型，<Integer>或<String>等</p><p>HashSet只传入一个参数，所以只指定一个泛型</p><p>HashMap传入键值，所以要指定两个泛型</p><p>Note：</p><ol><li>泛型不能写基本数据类型</li><li>若B继承A，这时就可以泛型写A，然后传入B</li><li>创建ArrayList的时候若什么都不写，则默认是Object</li></ol><p><strong>自定义泛型方法</strong></p><p>可以定义在泛型类也可以不在泛型类中</p><p>public后面写上&lt;T, R&gt;</p><p>即public &lt;T, R&gt; void fly(T t，R r)</p><p>泛型方法最好和泛型类类型一样，但是也可以使用自己定义的泛型</p><p>泛型方法调用的时候就必须指定相应的类型，直接传参数，编译器会自动确定对应的类型</p><p>注意传入的是100的话会自动装箱成Integer类型</p><p>Note：</p><p>e.getClass().getSimpleName()这里的getSimpleName表示只显示类名</p><p><strong>泛型的继承和通配符</strong></p><p>泛型不具备继承，即&#x3D;前后泛型必须一样，即不能转型</p><?>支持任意泛型类型<? extends A>支持任何A类的子类，最高是A<? super A>支持任何A类的父类，最低是A### 第十六章**坦克大战****绘图**像素是密度单位，厘米是长度单位，无法比较画图：1. 定义一个MyPanel类继承JPanel2. MyPanel类里定义方法paint方法，传入Graphics g参数————主要的画图核心3. 调用父类的paint方法完成初始化，super.paint(g)；4. Graphics g里面g是画笔，且Graphics提供了很多画图的方法5. drawOval方法传四个参数，x，y，width，height，其中x和y是圆形外接正方形的左上角6. 主类继承JFrame，定义画框7. 主类里面定义一个面板(属性)，MyPanel mp = null;8. 定义主类构造器，放入mp = new MyPanel9. 任何把面板放到窗口this.add(mp);10. 设置画框大小this.setSize(400,300)；   这里还可以加一个this.DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)用来让程序在点击红叉的时候结束11. 然后让它可以显示，this.setVisible(true);    12. 最后在主方法里面new一个主类的对象即可注意第一次在屏幕显示的时候系统会自动调用paint方法或最小化最大化的时候或窗口大小变化的时候repaint方法调用的时候**java事件处理机制**用键盘控制面板里小球的运动让MyPanel类同时再实现一个KeyListener接口，KeyListener是一个监听器，监听键盘的动作然后会重写好多方法，比如：keyTyped：有字符输出的时候会触发keyPressed：当键按下去的时候触发这里举例说明，该方法会传入一个KeyEvent e，事件类对象，然后(char)e.getKeyCode()方法可以获取具体哪个键被按下，然后将其转为字符，最后一步再主类构造器中将mp传入键盘监听类KeyListener，然后添加到图框中：构造器中：this.addKeyListener(mp);最后一步需要加上一句重绘，this.repaint();**注意**e.getKeyCode() == KeyEvent.VK_DOWN表示判断是不是按下了方向键下keyReleased：键放开的时候触发### 第十七章#### 进程指运行中的程序，比如QQ，操作系统会为该进程分配内存空间(程序——运行起来——进程)进程有产生，存在和消亡的过程**线程**线程由进程创建，是进程的一个实体一个进程可以拥有多个线程**单线程**同一个时刻只允许执行一个线程**多线程**同一个时刻可以执行多个线程**并发**单核CPU实现多任务就是并发，多个任务交替执行，造成同时的感觉**并行**多核CPU同时执行不同的任务并发并行可能同时存在#### 创建线程两种方法：1. 继承Thread类，重写run方法2. 实现Runnable接口，重写run方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//创建A对象</span></span><br><span class="line">        a.start(); <span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123; <span class="comment">//让A继承Thread类，但实际上Thread类也是实现了Runnable接口</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">8</span>) &#123; <span class="comment">//创造循环</span></span><br><span class="line">            System.out.println(<span class="string">&quot;fff&quot;</span>); <span class="comment">//输出</span></span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">//异常处理</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>); <span class="comment">//休眠500ms，毫秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>用start才会真正开启子线程，否则只是普通调用方法，本质还是主线程，会先run方法完再回到主方法，这就是串行化，会出现阻塞start方法本质会在底层调用start0方法，这才是真正实现多线程的方法，由JVM机调用**若该类已经继承了其他类，使用这时只能让它实现Runnable接口**<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//创建A对象</span></span><br><span class="line">        <span class="comment">//由于A没有start方法</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(a); <span class="comment">//需要创建一个Thread对象，将a放入，这里有一个代理模式</span></span><br><span class="line">        </span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上是代理设计模式多线程会发生同步互斥的问题，好几个线程一块进来，都执行任务，但是此时有可能已经不符合逻辑**线程终止**自动结束或通知方式，即在主线程利用变量终止run方法(终止while循环)**线程常用方法**a.interrupt方法，**中断休眠**，即提前结束休眠，但需要异常处理来捕获异常setName——设置线程的名称getName——获取名称Thread.MIN_PRIORITY——表示设置优先级yield线程的礼让，让出cpu，但是不一定成功，因为有的时候资源丰富，不需要礼让join线程的插队，一旦插入成功，则先执行插入的线程，这时cpu就会全部用来执行插入线程的任务直到执行完成再回到原来的线程**用户线程**也叫工作线程，执行完结束或通知方式结束**守护线程**为工作线程服务，所有用户线程结束后，守护线程自动结束，垃圾回收机制就是守护线程**将一个线程设置成是守护线程**直接a.setDaemon(true)即可，先设置守护，再start启动线程**线程生命周期**线程六种状态，getState获取状态其中Runnable状态可以细分为ready和runningRunnable只是可以运行的状态，是否运行取决于内核调度器**线程同步机制**保证任何同一时刻，最多一个线程访问内存，保证数据完整性再需要被同步的位置加上synchronized(对象)，用代码块包起来**互斥锁**每个对象都有一个互斥锁的标记，这个标记保证任意时刻只能有一个线程访问该对象局限性：程序执行效率降低需要同步的方法(非静态)的锁可以是this(即锁加在当前对象，如果要给代码块上锁，直接synchronized(this))，也可以是其他对象同步方法(静态的)的锁为当前类本身，即加在当前类，即synchronized(当前类名.class)**死锁**多个线程占用了锁资源，A拿到B的资源，B拿到A的资源，卡在这个地方**释放锁**同步方法中执行了wait()方法，线程暂停释放锁或同步方法中出现了未处理的异常或遇到了break，return语句也会释放锁而执行sleep，yield的时候不会释放锁或其他线程调用了suspend挂起方法，也不会释放锁，因为只是变成了ready，还在runnable***例题***<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建两个线程，第一个打印100内随机数，第二个从键盘接收Q时终止第一个线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//创建A对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(a); <span class="comment">//创建Thread对象将a传入以调用start方法</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">B</span>(a)); <span class="comment">//同理</span></span><br><span class="line">        thread.start(); <span class="comment">//启动线程A</span></span><br><span class="line">        thread1.start(); <span class="comment">//启动线程B</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//定义一个判断条件，当loop为false的时候停止循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop; <span class="comment">//为了让B线程能够调用这个方法来改变loop的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//线程A主体</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">100</span> + <span class="number">1</span>); <span class="comment">//100以内随机数</span></span><br><span class="line">            System.out.println(num); <span class="comment">//输出</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">//间隔2s</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">//创建B类</span></span><br><span class="line">    <span class="keyword">private</span> A a; <span class="comment">//定义一个A类型的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a; <span class="comment">//传入一个A类型的对象以便调用setLoop方法改变其值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//线程B主体</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); </span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> scanner.next().toUpperCase().charAt(<span class="number">0</span>); <span class="comment">//键盘接收</span></span><br><span class="line">        <span class="comment">//并将其转成大写，然后转成字符</span></span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;Q&#x27;</span>) &#123; <span class="comment">//判断</span></span><br><span class="line">            a.setLoop(<span class="literal">false</span>); <span class="comment">//通过a属性调用set方法从根本上改变loop的值来终止线程A</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>***例题2***<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个人共同取10000块钱，每次取1000，线程互斥锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(user);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(user);</span><br><span class="line">        p1.setName(<span class="string">&quot;第一个人&quot;</span>);</span><br><span class="line">        p2.setName(<span class="string">&quot;第二个人&quot;</span>);</span><br><span class="line">        p2.start();</span><br><span class="line">        p1.start();</span><br><span class="line">        <span class="comment">//以上是创建两个对象，分别启动线程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">//共享的数据要写在最前面作为属性</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//这里尽量用布尔值判断循环，目的是要将循环写在synchronized外面</span></span><br><span class="line">            <span class="comment">//同时将判断条件写在synchronized里面</span></span><br><span class="line">            <span class="comment">//循环写在外面可以让两个线程都进到循环中来抢夺锁，否则写在循环外的话</span></span><br><span class="line">            <span class="comment">//会造成一个线程抢到锁以后会一直循环，这中间另一个线程进不来循环</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">1000</span>) &#123; <span class="comment">//判断条件写在synchronized里面</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱成功&quot;</span>);</span><br><span class="line">                sum -= <span class="number">1000</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为&quot;</span> + sum);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;剩余&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础整理笔记下</title>
      <link href="/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E4%B8%8B/"/>
      <url>/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p>记录一些关于Java基础的常见知识点</p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h3 id="Java学习第十九章"><a href="#Java学习第十九章" class="headerlink" title="Java学习第十九章"></a>Java学习第十九章</h3><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p>输入输出六流都是以父类为后缀命名</p><p>文件就是保存数据的地方</p><p>文件在程序中以流的形式操作</p><p>从文件的数据读到内存，就是输入流</p><p>写入到文件就是输出流</p><p><strong>文件操作</strong></p><p>File类可以比较也可以串行化</p><p>创建文件：new File(String pathname路径)——但现在只是在内存里面</p><p>然后</p><p>或者new的时候将目录扔进去</p><p>然后file.createNewFile();——这时才真正写入磁盘</p><p>异常处理一下</p><p><strong>或者</strong></p><p>创建一个父类的文件目录</p><p>File parentFile &#x3D; new File(“父类目录”)——父类目录就是想要创建文件的哪个目录</p><p>然后单另写一个子类文件名称的字符串</p><p>最后再创建一个File对象，将之前对象和文件名字符串传入</p><p>然后create</p><p><strong>或者</strong></p><p>写两个字符串</p><p>一起传进File</p><p>然后create、</p><p><strong>文件夹创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\53196\\Desktop\\JAVA\\news&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span>(!(file.exists())) &#123;</span><br><span class="line">            file.mkdirs(); <span class="comment">//创建文件夹</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常用方法</strong></p><p>……</p><p><strong>创建目录和删除目录</strong></p><p>delete删除的只能是空目录</p><p><strong>先判断在不在目录下，有的话删除</strong></p><p>file.exist()——返回布尔值</p><p>true说明有，直接delete</p><p>false的话就删除失败</p><p><strong>判断一个目录(其实也是一个文件夹)在不在</strong></p><p>和上一个方法一样</p><h4 id="IO流-1"><a href="#IO流-1" class="headerlink" title="IO流"></a>IO流</h4><p>IO不一定非得是文件</p><p><strong>流的分类</strong></p><p>字节流(8位)，字符流(按字符)</p><p>字节流分为字节输入输出流</p><p><strong>字节输入流InputStream，</strong></p><p><strong>字符输入流是Reader</strong>，文本文件，汉字用这个</p><p><strong>字节输出流OutputStream，</strong></p><p><strong>字符输出流是Writer</strong></p><p>节点流和处理流</p><p><strong>创建输入流对象</strong></p><p>new 一个FileInputStream对象，传入文件路径然后可以调用方法读取文件</p><p>fileinputstream.read()——读取一个字节的数据，所以用while循环来读取所有数据，该方法读到最后一个数据会返回-1</p><p>显示的时候转成char</p><p>最后要在异常处理的finally里面关闭流，但是会抛异常</p><p>所以最后要在finally中用try-catch，然后在try中写上fileinputstream.close()来关闭流</p><p>inputstream的目的是可以让流和文件关联起来</p><p>但是中文会乱码，因为不是一个字节</p><p>除此之外，可以定义一个byte数组，一次性读取若干字节，比如8个字节</p><p>然后将这个数组传入read方法</p><p>显示的时候new一个String传入数组，0和需要显示的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\53196\\Desktop\\JAVA\\news1.txt&quot;</span>; <span class="comment">//记录文件路径</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//先定义一个输入流对象的引用名置空</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//索引</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path); <span class="comment">//真正创建一个输入流对象，传入路径赋给之前的引用名</span></span><br><span class="line">            <span class="keyword">while</span>((a = fileInputStream.read()) != -<span class="number">1</span>) &#123; <span class="comment">//当read方法返回的不是-1的时候继续循环</span></span><br><span class="line">                <span class="comment">//将read返回的数据赋值给a</span></span><br><span class="line">                System.out.print((<span class="type">char</span>)a); <span class="comment">//将返回的数据转成char类型输出，不换行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123; <span class="comment">//有异常就try-catch</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">//释放资源，关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close(); <span class="comment">//关闭也会有异常，仍然要try-catch</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>使用字节数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\53196\\Desktop\\JAVA\\news1.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//这里的a为最后一个位置的索引</span></span><br><span class="line">        <span class="type">byte</span> buf[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>]; <span class="comment">//创建一个字节数组，8给字节为一组来读取</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="keyword">while</span>((a = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123; <span class="comment">//传入数组</span></span><br><span class="line">                <span class="comment">//最后一个位置为-1退出循环</span></span><br><span class="line">                <span class="comment">//然后将数组转换成字符串，创建new一个字符串对象</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, a)); <span class="comment">//打印字符串对象，传入字节数组，起始结束索引，然后系统将这之间的数据给到字符串并输出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>FileOutputStream</strong></p><p>创建完FileOutputStream对象后直接</p><p>fileOutputStream.write(“a”)；这时就写进去一个a</p><p>若创建FileOutputStream对象的时候传入的目录没有该文件，则会自动创建一个文件</p><p>注意要想传入字符串，则可以write(str.getBytes())；getBytes可以将一个字符串转成一个字节数组</p><p>也可以getBytes(str.getBytes(), 0, 2)；表示只写数组的前三个</p><p>但是有一个问题，下一次再添加会覆盖之前的</p><p>索引需要创建的时候要new FileOutputStream（目录, true）;——这时就是追加的方式来写入数据</p><p><strong>文件拷贝</strong></p><ol><li>创建被拷贝文件的输入流，将文件读入到程序</li><li>创建输出流，将督导的数据写到目标文件中</li></ol><p>注意写的时候要write(buf, 0, a)；因为这样才能保证数据不缺失</p><p><strong>FileReader和FileWriter</strong></p><p>FileReader类对象的read是按照字符来读取，所以汉字是可以的，同时边读边……可以用char数组，按字符存</p><p>FileWriter类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\53196\\Desktop\\JAVA\\news2.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;hhhhhhhh&quot;</span>;</span><br><span class="line">            fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(path);</span><br><span class="line">            fileWriter.write(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(fileWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileWriter.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>节点流</strong></p><p>节点流可以从一个特定的数据源（比如特定的文件，或具体的数组，字符串等）读写数据，如FileReader</p><p>特点是直接访问，没有任何包装</p><p><strong>处理流</strong>（包装流）</p><p>对节点流进行一个包装，让它拥有更多的功能和方法</p><p>比如在BufferedReader类中有一个属性Reader，可以封装一个节点流，只要是Reader的子类都可以，这时候数据源就可以变化为任意一种数据源，文件等，即调用不同的reader来完成任务，不直接在底层与数据交流</p><p>举例BufferedReader读取</p><p>先给出字符串目录</p><p>然后创建BufferedReader的对象，传入一个新节点流FileReader对象，再将目录传入FileReader</p><p>定义行line给到String，这里的line就表示一行的字符串</p><p>然后就可以用BufferedReader类的方法，比如readLine按行读取，用line接收，当line为null结束循环</p><p>最后关闭流，注意这里只需要关闭外层的BufferedReader即可，bufferedReader.close()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\53196\\Desktop\\JAVA\\news2.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，添加的时候要是向追加，是在<strong>节点流</strong>里面加true</p><p>Buffer不能操作二进制文件，比如视频，声音，PDF</p><p><strong>BufferedInputStream和BufferedOutputStream</strong></p><p>这就是字节流，就可以对二进制文件进行操作</p><p>也是边读边写</p><p><strong>ObjectInputStream和ObjectOutputStream</strong></p><p>可以写文件的时候真正把int也保存进去，或者真正将Dog对象保存进去，保存数据类型，将来还能返回来一个对象</p><p>这就是序列化和反序列化，所以</p><p>存100：保存值</p><p>存int 100：序列化</p><p>将int 100再返回到程序里称为反序列化</p><p>要求：Dog类必须实现<strong>Serializable</strong>或者Externalizable接口之一，这样才支持序列化</p><p>ObjectInputStream提供反序列化功能</p><p>ObjectOutputStream提供序列化功能</p><p>先创建ObjectOutputStream对象，然后传入FileOutputStream，再传入路径</p><p>然后writeInt(100)；</p><p><strong>反序列化</strong></p><p>反序列化的顺序一定要和序列化一样</p><p>先创建ObjectInputStream对象，然后传入FileInputStream，再传入路径</p><p>然后readInt(ois)；ois是第一步创建的对象名</p><p>但是反序列化具体一个对象，加入要用到这个类的方法，需要将类的定义拷贝过来，或引入，或将类做成public</p><p>序列化对象的时候，类里面的static和transient修饰的成员不会被序列化</p><p>要求类里面的属性也要实现Serializable接口</p><p><strong>标准输入输出流</strong></p><p>System.in的编译类型是InputStream，运行类型是BufferedInputStream——表示标准输入，即键盘</p><p>System.in的编译和运行类型都是PrintStream——表示标准输出，即屏幕</p><p><strong>转换流</strong>——将字节流转为字符流</p><p>InputStreamReader</p><p>OutputStreamWriter</p><p>在字节流上指定一个编码类型，然后转成字符流</p><p>传入一个charset来设置编码格式</p><p>注意这里步骤要封装三次</p><p>先创建InputStreamReader对象，传入一个new FileInputStream对象和“gbk”编码格式(比如)</p><p>然后再创建一个BufferedReader()，将第一步创建的InputStreamReader对象传入，因为要方便的调用Buffered的方法来获取数据，这时候就不会出现乱码</p><p>Output的时候就不需要Buffered了</p><p><strong>打印流</strong></p><p>只有输出流，没有输入流</p><p><strong>PrintStream字节流</strong></p><p>PrintStream默认输出为标准输出，即显示器</p><p>也可以改变输出的位置：</p><p>System.setOut(new PrintStream(“e:\\f1.txt”))；表示将输出位置更改到这个文本文档中，而不是屏幕</p><p>这个时候再println，就不会出现在屏幕上</p><p>注意setOut方法用来改变输出的位置</p><p><strong>PrintWriter字符流</strong></p><p>先创建PrintWriter对象，然后传入一个FileWriter，传入路径</p><p>然后对象名.print(……)——这时会输出在路径指向的文件中</p><p><strong>注意一定要关闭流</strong></p><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>许多程序需要在配置文件中写，不能再程序中，这时就需要将数据写入配置文件，然后将数据再读取到程序中</p><p>properties类常见方法</p><p>load加载配置文件的键值对到Properties对象</p><p>list将数据显示到指定设备</p><p>getProperty(Key) ——根据键取值</p><p>读取步骤：</p><ol><li>创建Properties对象</li><li>加载指定配置文件，用对象名.load(new FileReader(路径))</li><li>将K-V显示在屏幕上，对象名.list(System.out)</li><li>根据Key获取对应的值，对象名.getProperty(“键名”)，然后赋给一个字符串变量</li></ol><p>修改某个键的值</p><ol><li><p>创建Properties对象</p></li><li><p>对象名.setProperty(“键名”, “新值”)，这里注意中文保存的时候存的是编码值</p><p>注意set方法若现在有就是修改，若没有就是添加</p></li><li><p>将K-V存储进文件，对象名.store(new FileOutputStream(“路径”)，null);——null这个位置就是一个注释</p></li></ol><p><strong>例题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=tom</span><br><span class="line">age=<span class="number">5</span></span><br><span class="line">color=red</span><br></pre></td></tr></table></figure><p>以上是配置文件dog.properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Properties将配置文件内的数据给到Dog对象的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">meiju</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\Users\\53196\\IdeaProjects\\Test\\src\\Chapter11\\dog.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(properties.getProperty(<span class="string">&quot;age&quot;</span>)); <span class="comment">//字符串转int</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;color&quot;</span>);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(name, age, color);</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：写文件的时候\r\n表示写的时候换行写</p><h3 id="Java学习第二十一章"><a href="#Java学习第二十一章" class="headerlink" title="Java学习第二十一章"></a>Java学习第二十一章</h3><h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><p><strong>网络通讯</strong></p><p>两台设备之间通过网络实现数据的传输</p><p>java.net——网络开发常用的类</p><p>网络分类：局域网，城域网，广域网</p><p>ip地址：用于标识网络中的每台计算机</p><p>对于IPV4，4个字节(32位)：</p><p>0<del>255  0</del>255  0<del>255  0</del>255(一个字节十进制数范围是0-255)</p><p>ip&#x3D;网络地址+主机地址</p><p>IPV6有128位表示一个地址，16个字节是IPV4的4倍</p><p>16进制保存</p><p>IPV4分为五类ABCDE</p><p>常用ABC，网络号分别为7，14，21位，主机号24，16，8位</p><p><strong>域名端口号</strong></p><p>域名作用将ip地址映射成域名，方便记忆，涉及HTTP协议映射</p><p>端口号：表示特定的网络程序，每个网站服务都会监听端口，电脑要想访问，则需要IP+端口就可以定位到该网络服务</p><p>IP确定网络站点，端口确定网站里的哪个服务</p><p>2个字节表示端口，端口范围0-65535</p><p>0-1024已经被占用，开发时不使用</p><p>常见网络端口号：</p><ol><li>mysql：3306</li><li>oracle：1521</li><li>tomcat：8080</li></ol><h4 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h4><p>网络编程中，数据的组织形式就是协议</p><p>分层(TCP&#x2F;IP模型)：应用层——传输层TCP——网络层IP——物理+数据链路层</p><p><strong>TCP和UDP协议</strong></p><p>TCP：传输控制协议</p><p>建立TCP连接，形成传输数据通道</p><p>传输前采用三次握手方式，是<em><strong>可靠</strong></em>的</p><p>连接中可进行大数据量的传输</p><p>传输完成，释放建立的连接，效率低</p><p><strong>三次握手</strong>：A：你在听吗</p><p>B：在听</p><p>A：和你说个事</p><p>A：开始传输大量数据</p><p>UDP：用户数据协议</p><p>将数据，源，目的封装成数据包，不需要建立连接</p><p>每个数据报大小限制在64k内，不适合大量传输数据</p><p>因为无需连接，所以不可靠</p><p>结束后无需释放资源，所以速度快</p><p>A：直接对着一个地方说话，也不管对方在不在</p><p><strong>InetAddress类</strong>，获取本机名和Ip或服务器的域名Ip</p><p>getLocalHost()会输出计算机名和IP地址</p><p>getByName（传入计算机名），得到计算机名和IP</p><p>getAllByName(“一个域名”)得到域名和其对应的IP</p><p>不只可以通过类名直接调用，返回给一个对象，还可以通过对象名调用</p><p><strong>Socket</strong></p><p>套接字</p><p>发起连接的一端为客户端</p><p>接收请求连接为服务端(监听)</p><p>当需要通讯时，即读写数据时</p><p>通过socket.getInputStream或getOutputStream两个方法读写</p><p>基于socket有两种编程方式，TCP和UDP</p><p>最终一定要关闭socket.close（）</p><h4 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h4><p>客户端编程：</p><ol><li>连接服务端（ip和端口）</li><li>连接上后，生成socket，通过socket.getOutputStream将数据写到数据通道</li></ol><p>服务端编程：</p><ol><li>再本机的9999端口监听，等待连接</li></ol><p>ServerSocket serverSocket &#x3D; new ServerSocket(9999),要求本机没有其他服务监听9999端口</p><p>Socket socket &#x3D; serverSocket.accept()表示若有客户端连接，则返回一个Socket对象，若无，则会阻塞在这里</p><ol><li>当没有客户端连接9999时，程序阻塞，等待连接</li><li>通过serverSocket.accept方法来接收客户端连接，注意，可以多个连接，然后返回一个Socket对象</li><li>通过socket.getInputStream()读取客户端写入到数据通道的数据，显示</li><li>通过socket调用getInputStream来读取数据，可以用byte数组</li><li>关闭流对象和socket以及serversocket</li></ol><p>客户端编程：</p><ol><li>Socket socket &#x3D; new Socket(InetAddress.getLocalHost(), 9999)；即服务器的IP和端口，连接成功则返回Socket对象</li><li>通过这个socket调用getOutputStream给到一个对象，然后再用这个对象调用write(“sdasd”.getBytes())；</li><li>关闭流和socket</li></ol><p>注意，发送完毕后要设置写入结束标记，不管是服务器还是客户端，socket.shutdownOutput();</p><p>或者writer.newLine()来设置，但是需要对方用readLine读取数据</p><p>案例，使用字节流，客户端发送数据，服务端读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建serverSocket对象传入端口等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器等待连接&quot;</span>);</span><br><span class="line">        <span class="comment">//然后通过accept方法接收客户端的连接，可能不只一个</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接客户端&quot;</span>);</span><br><span class="line">        <span class="comment">//通过socket调用getInputStream创建inputStream读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span> buf[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readlen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readlen = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readlen));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建Socket传入IP和端口来连接服务器</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接服务器&quot;</span>);</span><br><span class="line">        <span class="comment">//然后通过socket调用getOutputStream方法来创建outputStream对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//通过outputStream对象来写入内容</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;Hello&quot;</span>.getBytes());</span><br><span class="line">        socket.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若用字符流</p><p>则需要将字节流转成字符流</p><p>用OutputStreamWriter（字节流）或InputStreamReader（字节流）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建serverSocket对象传入端口等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器等待连接&quot;</span>);</span><br><span class="line">        <span class="comment">//然后通过accept方法接收客户端的连接，可能不只一个</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接客户端&quot;</span>);</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        <span class="comment">//通过socket调用getInputStream创建inputStream读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//还是将字节流转换成字符流然后封装为BufferedReader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        System.out.println(br.readLine()); <span class="comment">//按行读取</span></span><br><span class="line"><span class="comment">//回写数据</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bw.write(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.flush();</span><br><span class="line"><span class="comment">//关闭</span></span><br><span class="line">        bw.close(); <span class="comment">//按顺序从后往前关闭</span></span><br><span class="line">        br.close(); <span class="comment">//注意这里关闭外层即可</span></span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建Socket传入IP和端口来连接服务器</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;已连接服务器&quot;</span>);</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        <span class="comment">//然后通过socket调用getOutputStream方法来创建outputStream对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//通过转换流OutputStreamWriter来将字节流对象outputStream转换成字符流然后封装成Buffered</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bw.write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        bw.newLine(); <span class="comment">//相当于结束标记，但是对方必须用readLine读取，注意先结束，再刷新</span></span><br><span class="line">        bw.flush(); <span class="comment">//若使用字符流，需要手动刷新</span></span><br><span class="line"><span class="comment">//读取回写的数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        System.out.println(br.readLine());</span><br><span class="line">        </span><br><span class="line">        br.close(); <span class="comment">//先关闭最后打开的流</span></span><br><span class="line">        bw.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TCP网络通信编程</strong></p><p>端口监听和网络连接情况</p><p>本地地址就是端口，外部地址一般指客户端的IP</p><p>netstat -an控制台下会显示以上信息</p><p>Note：实际上客户端也是通过一个端口与服务端进行通讯，这个端口是IP&#x2F;TCP随机分配的</p><p><strong>UDP网络编程</strong></p><p>……</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传输音乐，客户端发请求，服务端发音乐，客户端接收</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器监听端口……&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收客户端发来的音乐名请求</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> br.readLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始从服务器中读取对应的音乐</span></span><br><span class="line">        <span class="comment">//先判断有没有这个音乐，采取目录字符串拼接的方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pathOrigin</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\53196\\Desktop\\JAVA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> pathOrigin + <span class="string">&quot;\\&quot;</span> + answer + <span class="string">&quot;.mp3&quot;</span>;</span><br><span class="line">        System.out.println(path);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span>(file.exists()) &#123;</span><br><span class="line">            <span class="comment">//有这个音乐，开始读取到程序中，音乐文件为字节流</span></span><br><span class="line">            <span class="comment">//先将音乐数据转为字节流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream_read</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="comment">//再用工具类将字节流转为字节</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = StreamUtils.streamToByteArray(inputStream_read);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//准备发给通道，写入数据</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(outputStream);</span><br><span class="line">            bos.write(bytes);</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            bos.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//然后返回默认音乐</span></span><br><span class="line">            <span class="comment">//先将默认音乐读到程序中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">pathDefault</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\53196\\Desktop\\JAVA\\流水人家.mp3&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream_readDefault</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(pathDefault);</span><br><span class="line">            <span class="type">byte</span>[] bytes = StreamUtils.streamToByteArray(inputStream_readDefault);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入通道</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(outputStream));</span><br><span class="line">            bos.write(bytes);</span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            bos.flush();</span><br><span class="line"></span><br><span class="line">            bos.close();</span><br><span class="line">            inputStream_readDefault.close();</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提示信息，然后将answer发给通道，这里是字符流</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个音乐名: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        bw.write(answer);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.flush();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//准备接收服务端的音乐文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(inputStream);</span><br><span class="line">        <span class="type">byte</span>[] bytes = StreamUtils.streamToByteArray(bis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到字节数据后可以写入目标文件中</span></span><br><span class="line">    </span><br><span class="line">        <span class="type">String</span> <span class="variable">pathTarget</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\53196\\IdeaProjects\\Test\\src\\&quot;</span> + answer + <span class="string">&quot;.mp3&quot;</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream_write</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(pathTarget);</span><br><span class="line">        outputStream_write.write(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;收到音乐&quot;</span>);</span><br><span class="line"></span><br><span class="line">        outputStream_write.close();</span><br><span class="line">        bw.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Java学习第二十二章"><a href="#Java学习第二十二章" class="headerlink" title="Java学习第二十二章"></a>Java学习第二十二章</h3><h4 id="多用户通讯系统编程"><a href="#多用户通讯系统编程" class="headerlink" title="多用户通讯系统编程"></a>多用户通讯系统编程</h4><h4 id="QQ项目"><a href="#QQ项目" class="headerlink" title="QQ项目"></a>QQ项目</h4><p><strong>项目开发流程</strong></p><p>需求分析</p><p>设计阶段——UML类图——流程图——模块设计——数据库——架构——原型开发</p><p>实现阶段——程序员完成架构师模块功能——测试自己的模块</p><p>测试阶段——单元测试——白盒黑盒测试——集成测试</p><p>实施阶段——项目正确部署到客户的平台保证运行正常</p><p>维护阶段——发现bug及时解决</p><p>QQ需求分析</p><p>用户登录，拉取在线用户列表，无异常退出(服务器和客户端)，私聊，发文件，服务器推送行为</p><h3 id="Java学习第二十三章"><a href="#Java学习第二十三章" class="headerlink" title="Java学习第二十三章"></a>Java学习第二十三章</h3><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>将配置文件里的信息直接放到程序中运行，其价值是不用修改定义Cat对象的原码，只需要修改配置文件，就可以调用</p><ol><li>先加载类，返回一个class类的对象Class cls &#x3D; Class.forname(classfullpath)</li><li>Object o &#x3D; cls.newInstance()，这里就得到了目标类的对象</li><li>Method method &#x3D; cls.getMethod(methodName)，反射里面将方法也看作对象，其中methodName是之前读到的方法名</li><li>通过方法对象来最终实现调用方法，method.invoke(o)</li></ol><p><strong>cls</strong>即Class类</p><p>cls可以调用各种方法</p><p>获取类的方法</p><p>类名&#x2F;基本数据类型.class来获取其属于哪个类</p><p><strong>静态加载类</strong>：编译的时候就加载类，依赖性高，不管运行的时候用不用到这个类，都会加载，new一个对象就是这样，所以必须编写这个类才能编译通过</p><p><strong>动态加载类</strong>：编译的时候不管，只要运行到这一行代码的时候才去加载类，比如forName反射，即使没有编写这个类，编译的时候也不会报错，只有运行到这个地方发现没有才会报错</p><h3 id="Java学习第二十四章"><a href="#Java学习第二十四章" class="headerlink" title="Java学习第二十四章"></a>Java学习第二十四章</h3><h4 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h4><p>客户端连接mysql的指令</p><p>mysql -h 主机IP -P 端口 -u 用户名 -p密码</p><p>-p后没有空格</p><p>没有写-h的话默认连接到本机</p><p>没有写-P端口，默认为3306</p><p>在java中，一个对象对应一行记录，即表的一行</p><p>DDL定义语句 create</p><p>DML操作语句 insert update delete</p><p>DQL查询 select</p><p>DCL管理数据库用户权限 grant授权 revoke撤权</p><p>创建数据库的时候可以使用&#96;&#96;反引号规避关键字 CREATE DATABASE 数据库名</p><p>备份数据库得在DoS执行，恢复数据库在mysql命令行执行，即在DoS下登录mysql，然后再输入source</p><p>备份数据库，mysqldump -u root -p -B db01 db02 &gt; 目录</p><p>注意，若只想备份数据库的其中一个表，就mysqldump -u root -p db01 t1 &gt; 目录</p><p>恢复数据库，source 目录</p><p><strong>创建表</strong></p><p>CREATE TABLE t2(<br>    id INT,<br>    `name` VARCHAR(255),<br>    `password` VARCHAR(32),<br>    birthday DATE<br>) CHARACTER SET utf8 COLLATE utf8_bin ENGINE INNODB</p><p><strong>列数据类型</strong></p><p><strong>数值类型</strong></p><p>整型：tinyint(1个字节)，smallint(2个字节)，mediumint(3个字节)，**int(4个字节)**，bigint(8个字节)</p><p>小数类型：float(单精度4个字节)，double(双精度8个字节)，decimal[M,D]（大小不确定）</p><p><strong>文本类型</strong></p><p>char 0-255，varchar 0-65535，text 0-65535，longtext 0-2^32 - 1</p><p><strong>二进制数据类型</strong></p><p>blob 0-2^16 - 1</p><p>longblob 0-2^32 - 1</p><p><strong>日期类型</strong></p><p>date(日期，年月日)</p><p>time(时间，时分秒)</p><p>datetime(年月日时分秒，YYYY-MM-DD HH:mm:ss)</p><p>timestamp(时间戳)</p><p>year年</p><p><strong>select语句</strong></p><p>单表多表</p><p>SELECT 列名, 列名2 FROM 表名</p><p>改变查询时显示出来的列名</p><p>SELECT name AS name1 FROM 表名</p><p>还可以运算，比如加起来总分</p><p><strong>LIKE</strong>模糊查询，%表示一个占位符</p><p>ORDER BY 列名，升序排序显示</p><p>ORDER BY 列名 DESC 就是降序</p><p>COUNT(*)函数，返回满足条件的总行数</p><p>COUNT(列名)会排除null的情况</p><p>SUM(列名)表示将该列的数值相加返回</p><p>AVG平均值</p><p>MAX&#x2F;MIN最大最小值</p><p>GROUP BY按照……来分组显示</p><p>若GROUP BY 1,2表示先按照1分组，再按照2分组</p><p><strong>多表</strong>查询方式为取出第一张表和第二张表的每一行拼接，最终组成一个笛卡尔集</p><p>所以需要写出过滤条件where</p><p>表名.字段 &#x3D; 表2名.字段</p><p>自连接</p><p>一张表当作两张表来用</p><p>而且可以将子查询当成一个临时表，来简化操作</p><h3 id="java连接mysql数据库"><a href="#java连接mysql数据库" class="headerlink" title="java连接mysql数据库"></a>java连接mysql数据库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/db01</span></span><br><span class="line">users=root</span><br><span class="line">password=zkq</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, IOException &#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Cat.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jb.properties&quot;</span>);</span><br><span class="line">        <span class="comment">//创建properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        properties.load(in);</span><br><span class="line">        <span class="comment">//读取配置文件中的url表示mysql用户IP端口和数据库的名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        <span class="comment">//读取配置文件中的用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">users</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="comment">//读取配置文件中的密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">        <span class="comment">//将url用户名密码传给connection来取得数据库的连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(url, users, password);</span><br><span class="line">        <span class="comment">//将sql语句包起来赋给sql字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods values(&#x27;30&#x27;, &#x27;小米手机&#x27;, &#x27;3000&#x27;)&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个声明statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">        <span class="comment">//执行sql语句，rows表示受影响的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">        System.out.println(rows);</span><br></pre></td></tr></table></figure><h4 id="一般推荐："><a href="#一般推荐：" class="headerlink" title="一般推荐："></a>一般推荐：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//加载Driver类时底层有一个静态代码块会自动进行驱动注册</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;zkq&quot;</span>;</span><br><span class="line">        <span class="comment">//直接获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用配置文件优化方案"><a href="#利用配置文件优化方案" class="headerlink" title="利用配置文件优化方案"></a>利用配置文件优化方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException, IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//创建一个properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//加载配置文件</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\jb.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//根据键来依次获取用户名密码url和driver驱动</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="comment">//完成加载驱动，也可以不写，因为会自动加载</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        <span class="comment">//获得连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>步骤：</p><ol start="0"><li><p>创建工程，导入MySQL的jar包，可以放在lib文件夹里，然后add as library</p></li><li><p>注册驱动，反射加载Class.forName(“com.mysql.jdbc.Driver”)，不写也可以</p></li><li><p>获取连接(对象)，Connection conn &#x3D; DriverManager.getConnection(url, username, password);</p></li><li><p>写sql语句，String sql &#x3D; “update ……”;</p></li><li><p>获取用于执行sql语句的Statement对象，Statement stmt &#x3D; conn.createStatement();</p></li><li><p>执行sql语句，stmt.executeUpdate(sql);</p></li><li><p>处理返回结果，可以将5中执行后的结果返回给int res，即受影响的行数</p></li><li><p>释放资源，依次stmt.close();和conn.close();</p></li></ol><p><strong>Connection:</strong></p><ol><li>获取执行sql语句的对象</li><li>事物管理，用conn.setAutoCommit(false)来开启事务，用conn.commit()来提交事务，用conn.rollback()来回滚事务（在try-catch里写提交和回滚）</li></ol><p><strong>Statement</strong></p><p>执行sql语句</p><p>三种语句：DML对于表的增删改，DDL对于表和库的增删改查，DQL对于表的查询</p><p><strong>ResultSet</strong></p><p>结果集对象，封装了DQL查询的结果</p><p>用executeQuery(sql)，将返回值给到res</p><p>res.next()将光标向前移动一行并判断是否为有效行，返回true为有效行</p><p>res.getXXX(形参)，XXX表示当前列的数据类型，形参可以写整数(表示当前列号，从1开始)，写字符串(表示列名)</p><p>一般的查询后处理方式：</p><ol><li>定义一个实体类，将数据库的字段都定义在类中</li><li>查询数据，将结果封装在对象中，做到 一行数据一个对象</li><li>将所有对象存入ArrayList集合中</li></ol><p><strong>PreparedStatement</strong></p><p>防止sql注入，因为将敏感字符进行转义导致无法拼接字符串</p><p>这时sql语句中的username和password要写成？占位符</p><p>然后PreparedStatement pstmt &#x3D; conn.prepareStatement(sql)注意传入sql语句</p><p>然后设置参数值，pstmt.setXXX(参数1，参数2)</p><p>XXX为数据类型，参数1为第几个？，参数2为要给到？的值</p><p>最后executeUpdate()或executeQuery()，这时不需要再传sql</p><p>预编译功能：在url后边加？useServerPrepStmts&#x3D;true</p><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><ol><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏，连接池强行回收占用的资源返回容器并给到下一个用户</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础整理笔记上</title>
      <link href="/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E4%B8%8A/"/>
      <url>/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>记录一些关于Java基础的常见知识点</p><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h3 id="Java学习第一章"><a href="#Java学习第一章" class="headerlink" title="Java学习第一章"></a>Java学习第一章</h3><p>程序—有序指令的集合</p><p>Java 8 &amp; 11 (LTS——Long Term Support—长期支持版)</p><h4 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h4><ol><li>面向对象(oop)</li><li>健壮(强类型机制，异常处理，垃圾自动回收)</li><li>跨平台(编译好的.class文件在多个操作系统上运行)</li><li>解释型语言(编译后需要解释器才可执行，而编译型语言c&#x2F;c++编译后为2进制可以直接被机器执行)</li></ol><h4 id="Java运行流程"><a href="#Java运行流程" class="headerlink" title="Java运行流程"></a>Java运行流程</h4><p><strong>Test.java源文件</strong> ——*编译(javac指令)*—— **Test.class字节码文件 *<em>——</em>运行(java指令)*—— <strong>各种JVM(Java Virtual Machine——Java虚拟机)</strong> —— <strong>操作系统</strong></p><p><strong>JDK(Java Development Kit)Java开发工具包</strong></p><p>包含JRE和Java开发工具(javac, javadoc, javap, java)</p><p><strong>JRE(Java Runtime Environment——Java运行环境)</strong></p><p>包含JVM和Java核心类库(类)</p><h3 id="Java学习第二章"><a href="#Java学习第二章" class="headerlink" title="Java学习第二章"></a>Java学习第二章</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class Hello表示Hello是一个公有的类</span></span><br><span class="line"><span class="comment">//Hello&#123;&#125;表示一个类的开始和结束</span></span><br><span class="line"><span class="comment">//public static void main(string[] args)表示一个主方法，即程序的入口</span></span><br><span class="line"><span class="comment">//main&#123;&#125;表示方法的开始和结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note: </p><ol><li>注意大小写</li><li>源文件的基本组成是 类</li><li>每个源文件最多一个public类，文件名必须与public类名一致，但其他类数量不限</li></ol><h4 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h4><ol><li>搞清楚为什么学</li><li>考虑传统技术(现掌握的)能不能解决问题</li><li>引出新技术的知识点</li><li>学习技术的基本原理与基本语法(不考虑细节)</li><li>写快速入门的案例(crud，增删改查)</li><li>研究技术的注意事项，使用细节，使用规范，优化(无止境，拉开差距的主要方面)</li></ol><h4 id="Java转义字符"><a href="#Java转义字符" class="headerlink" title="Java转义字符"></a>Java转义字符</h4><table><thead><tr><th align="center">转义字符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">\t</td><td align="center">制表位</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\\</td><td align="center">输出一个\</td></tr><tr><td align="center">\“</td><td align="center">输出一个”</td></tr><tr><td align="center">\r</td><td align="center">回车，光标回到本行开头</td></tr></tbody></table><p>Note: 回车不是传统意义上的回车，换行不代表光标后面的也要去到下一行</p><h4 id="常犯的错误"><a href="#常犯的错误" class="headerlink" title="常犯的错误"></a>常犯的错误</h4><p>业务逻辑错误，环境错误</p><h4 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h4><p>多行注释：&#x2F;*……*&#x2F;</p><p>注释快捷键：ctrl + &#x2F;</p><p>文档注释：对类和方法和属性等功能的说明，便于维护程序，可自动生成网页文件的形式</p><p>一般描述一个类或方法分三块</p><ol><li><p>一句话概要描述该类或方法的作用(用句点结尾)</p></li><li><p>一段或多段详细描述该类或方法的作用(一般开头是<p>，每段用句点结尾)</p></li><li><p>类的javadoc：文档标注作者信息，版本，参阅信息等(即@author)</p><p>方法的javadoc：文档标注参数，返回值，异常等</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Niki</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>在控制台中输入：javadoc -d d:……\\temp -xx -yy Hello.java</p><p>xx和yy是文档注释的javadoc标签：</p><ol><li><p>author</p></li><li><p>version——当前版本(since——从哪个版本开始)</p></li><li><p>docroot——表示产生文档的根目录</p></li><li><p>deprecated——表示过期的方法</p></li><li><p>param——方法的参数类型</p></li><li><p>return——方法的返回类型</p></li><li><p>see——另请参阅</p></li><li><p>exception或throws——抛出异常值</p><p>……</p></li></ol><h4 id="DOS系统"><a href="#DOS系统" class="headerlink" title="DOS系统"></a>DOS系统</h4><p>DOS：Disk Operating System——磁盘操作系统</p><p><strong>md d: \\文件名</strong>——增加一个文件夹</p><p><strong>rd d: \\文件名</strong>——删除一个文件夹</p><p><strong>dir</strong> 查看当前目录有什么内容(或者<em>dir d:……</em>，用绝对路径访问目标目录下有什么内容)</p><p><strong>cd &#x2F;D c:……</strong>——切换到其他盘(C盘)，&#x2F;D为开关</p><p><strong>cd d:……</strong>——切换到该盘的其他目录下(相对和绝对)</p><p><strong>cd \</strong>——直接回到顶级目录(根目录)</p><p><strong>tree d:……</strong>——查看目录树</p><p><strong>cls</strong>——清屏</p><p><strong>exit</strong>——退出</p><p>**cd ..**——回到上一级目录</p><p>Note: </p><p>相对路径：从当前目录(文件夹)开始定位，形成的一个路径</p><p>绝对路径：从顶级目录开始定位(D盘)，形成的路径</p><hr><p>第一章练习：</p><ol><li><p>编写”Hello,world”</p></li><li><p>编写姓名性别籍贯住址各占一列输出</p></li><li><p>JDK,JRE,JVM的关系</p></li><li><p>为什么配置环境变量，怎么配置</p></li></ol><h3 id="第一二章练习"><a href="#第一二章练习" class="headerlink" title="第一二章练习"></a>第一二章练习</h3><ol><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将个人信息(姓名、性别、籍贯、住址)打印到控制台上，每条信息各占一行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework02</span> &#123;</span><br><span class="line"><span class="comment">//编写一个主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//屏幕上输出Hello,world</span></span><br><span class="line">System.out.println(<span class="string">&quot;姓名\t性别\t籍贯\t住址\n张珂奇\t男\t山西\t上海&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK,JRE,JVM的关系</span></span><br><span class="line"><span class="comment">//1. JDK = JRE + java开发工具</span></span><br><span class="line"><span class="comment">//2. JRE = JVM + java核心类库</span></span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环境变量path配置及其作用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 环境变量是为了在DOS的任意目录都可以使用javac，java等命令</span></span><br><span class="line"><span class="comment">2. 先添加JAVA_HOME,即JDK的目录，然后编辑path环境变量，增加%JAVA_HOME%\bin,</span></span><br><span class="line"><span class="comment">   其中%……%是引用，其作用等同于写一个JDK的目录，一旦JDK目录发生改变，则需要</span></span><br><span class="line"><span class="comment">   在path里修改所有目录，但引用不会，只需要修改变量里面的JAVA_HOME的目录</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Note：print就不换行，println换行(输出完本行内容后才换行)</p><h3 id="Java学习第三章"><a href="#Java学习第三章" class="headerlink" title="Java学习第三章"></a>Java学习第三章</h3><h4 id="Java-API文档"><a href="#Java-API文档" class="headerlink" title="Java API文档"></a>Java API文档</h4><p>API(Application Programming Interface——应用程序编程接口)，即java提供的一些类和方法</p><p>统一放在Java API文档里面</p><p>Java类的组织形式</p><p>JDK8，11</p><ol><li><p>若干包(相当于文件夹，根据类的不同来分类管理)</p><p>a. 若干接口</p><p>b. 若干类</p><pre><code>* 字段……* 构造器(构造方法)* 成员方法(方法)</code></pre><p>c. 枚举</p><p>d. 异常</p></li></ol><p>查找方法：包——类——方法</p><h4 id="变量-类型-名称-值"><a href="#变量-类型-名称-值" class="headerlink" title="变量(类型+名称+值)"></a>变量(类型+名称+值)</h4><p>int a &#x3D; 3;</p><p><strong>类型</strong>：int整数型，double浮点型，char字符型(‘ ‘)，String字符串型(“ “)</p><p><strong>+的使用</strong>：当左右两边全是数值型，则加法；有一方是字符串，则拼接(从左到右)</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>基本数据类型</strong></p><ol><li><p>数值型</p><p>a. 整数类型，四种：byte[1], short[2], int[4], long[8]</p></li></ol><p>​       b. 浮点类型，两种：float[4], double[8]</p><ol start="2"><li>字符型，char[2]，存放单个字符(汉字占两个字节)</li><li>布尔型，boolean[1]，存放true和false</li></ol><p><strong>引用数据类型</strong></p><ol><li>类calss(String是类)</li><li>接口interface</li><li>数组[ ]</li></ol><p><em><strong>整数类型</strong></em></p><p>Java整数类型不受OS(操作系统)影响，以保证java程序的可移植性(不管在哪个OS下，int都是4个字节)</p><p>如果要声明long类型，需要：long a &#x3D; 1L(因为常量在java中默认是int型的，即这里的1，所以要加L)</p><p><em>Note：不加 “L”也可以，相当于强制类型转换，当常量不在int范围时会报错</em></p><p>bit是最小的存储单位，byte是基本存储单位，一个byte &#x3D; 八个bit</p><p><em><strong>浮点类型</strong></em></p><p>浮点数存储机制：浮点数 &#x3D; 符号位 + 指数位 + 尾数位</p><p>由于尾数部分可能丢失，所以小数都是近似值</p><p>浮点型默认为double型，float需要：float n &#x3D; 1.1f(可以double n &#x3D; 1.1f)</p><p><em><strong>字符类型</strong></em></p><p>两个字节，单个字符</p><p>char的本质是一个整数，输出时是Unicode码(整数)对应的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;张&#x27;</span>;</span><br><span class="line">System.out.println((<span class="type">int</span>)c); <span class="comment">//输出汉字对应的Unicode码，需转换整型</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反，整数对应ASCII编码表</p><p>字符存储流程：’a’——编码表——97——二进制(0110 0000)——存储</p><p>字符读取流程：二进制(0110 0001)——97——编码表——‘a’</p><p>Notes:</p><ol><li><p>ASCII编码表用一个字节表示，一个字节8位，可以表示256个字符(-128—127总共256个二进制数)</p><p>但ASCII表只用了128个字符</p></li><li><p>字符是’a’, ‘%’, ‘哈’等这些符号，一般占用一个字节，汉字在GBK或ASCII下占两个字节，在UTF-8占三个字节</p></li><li><p>”占“表示的是占位，但是不妨碍一个字节可以有8位，有256个不同的二进制占位选择</p></li><li><p>Unicode汉字字母都占2个字节</p></li><li><p>UTF-8字母占1个字节，汉字占3个字节</p></li><li><p>GBK字母占1个字节，汉字占2个字节</p></li></ol><p><em><strong>布尔类型</strong></em></p><p>Boolean，只能等于true或false</p><h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><p>精度小的类型可以自动转成精度大的类型(容量小的可以往大容量转)</p><p>char——int——long——float——double</p><p>byte——short——int——long——float——double</p><p>前者可自动转成后者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>; <span class="comment">//正确的，即字符转成整数型，输出99</span></span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//正确的，即整型转成双精度浮点型，输出10.0</span></span><br></pre></td></tr></table></figure><p>Notes：</p><ol><li><p>混合类型计算时，系统会自动将整个算式换成当前操作数中最大的那个数据类型，再计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1.1f</span>; <span class="comment">//1.1要带f，否则，默认double不能往float转</span></span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1.1</span>; <span class="comment">//这时=右边是最高精度的数据类型double，不能转float</span></span><br></pre></td></tr></table></figure></li><li><p>char和(byte和short)之间不发生转换，当把<strong>数字</strong>赋值给byte时，若该数范围在byte内，则可以倒转，若&#x3D;右边是一个int变量，因为已经将数字存储到了4个字节的空间，所以这时不能转byte</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//在-128-127范围内，所以默认int型的127可以转成byte</span></span><br></pre></td></tr></table></figure></li><li><p>但是char，byte和short三者可以计算，计算时会首先自动转成int(&#x3D;右边会自动变成int)，包括byte与byte，char与char计算的时候也会自动转成int(char类型则自动转换成字符的码值)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">c</span> <span class="operator">=</span> a + b; <span class="comment">//错的，这时=右边会自动变成int类型，不能倒转成short</span></span><br></pre></td></tr></table></figure></li><li><p>Boolean不参与类型的自动转换</p></li></ol><p><strong>强制转换数据类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1.9</span>; <span class="comment">//取整，精度丢失，结果为1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> (<span class="type">byte</span>)<span class="number">2000</span>; <span class="comment">//造成数据溢出，结果为-48</span></span><br></pre></td></tr></table></figure><p>Note：int强制转char时，即(char)100时，不存在’100’，只会输出100对应的字符d</p><p><strong>基本数据类型转String</strong></p><p><em>基本数据类型 + “ “</em> 就可以转换成字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span> + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>String转基本数据类型</strong></p><p>使用基本数据类型的包装类(int的包装类是Integer)的相应方法可以得到基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">//输出123</span></span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;123&quot;</span>); <span class="comment">//输出123.0</span></span><br></pre></td></tr></table></figure><p>Note：字符串转字符只会把字符串的对应单个字符取到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">System.out.println(a.charAt(<span class="number">0</span>)); <span class="comment">//输出第一个字符，下标从0开始</span></span><br></pre></td></tr></table></figure><h3 id="第三章练习"><a href="#第三章练习" class="headerlink" title="第三章练习"></a>第三章练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用不同的变量存储姓名、年龄、成绩、性别、爱好</span></span><br><span class="line"><span class="comment">使用+</span></span><br><span class="line"><span class="comment">添加适当注释</span></span><br><span class="line"><span class="comment">添加转义字符，使用一条语句输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张珂奇&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">90.0</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">hobby</span> <span class="operator">=</span> <span class="string">&quot;足球&quot;</span>;</span><br><span class="line"><span class="comment">//输出时可以使用换行</span></span><br><span class="line">System.out.println(<span class="string">&quot;姓名\t年龄\t成绩\t性别\t爱好\n&quot;</span> + name + <span class="string">&quot;\t&quot;</span> </span><br><span class="line">+ age + <span class="string">&quot;\t&quot;</span> + score + <span class="string">&quot;\t&quot;</span> + gender + <span class="string">&quot;\t&quot;</span> + hobby + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java学习第四章"><a href="#Java学习第四章" class="headerlink" title="Java学习第四章"></a>Java学习第四章</h3><h4 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h4><p><strong>算术运算符</strong></p><p>对数值类型的变量进行运算</p><p>除法(10 &#x2F; 4)赋值给double以后只会得到2.0，因为10和4都是整数型，除非换成10.0 &#x2F; 4</p><p>取模取余的本质，<strong>a % b &#x3D; a - a &#x2F; b * b</strong>，所以10 % -3是1</p><p>当a是小数时，公式为a % b &#x3D; a - int(a) &#x2F; b * b</p><p>a &#x3D; i++，先把i赋值给a，然后i再自加1</p><p>a &#x3D; ++i，i先自加1，然后把加1后的i赋值给a</p><p>Notes：若是逻辑运算判断，即i++ &#x3D;&#x3D; 5，表示先判断，i再自增；若++i &#x3D;&#x3D; 5，表示先自增，然后用自增之后的值判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i = i++; <span class="comment">//涉及计算机规则:使用临时变量 (1)temp=i (2)i=i+1 (3)i=temp</span></span><br><span class="line">System.out.println(i); <span class="comment">//输出结果为1 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题输出结果为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i = ++i; <span class="comment">//涉及计算机规则:使用临时变量 (1)i=i+1 (2)temp=i (3)i=temp</span></span><br><span class="line">System.out.println(i); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题输出结果为2</p><p><em><strong>编程小练习</strong></em></p><ol><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> <span class="number">2125</span>; <span class="comment">//需要定义一个days，只需修改一个days的值就可以</span></span><br><span class="line"><span class="type">int</span> <span class="variable">weeks</span> <span class="operator">=</span> days / <span class="number">7</span>; <span class="comment">//如果直接2125 / 7，后续修改天数需要改三个位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">leftDays</span> <span class="operator">=</span> days % <span class="number">7</span>;</span><br><span class="line">System.out.println(days + <span class="string">&quot;天，合&quot;</span> + weeks + <span class="string">&quot;个星期零&quot;</span> + </span><br><span class="line">leftDays + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">double</span> <span class="variable">fahrenheit</span> <span class="operator">=</span> <span class="number">234.5</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">centigrade</span> <span class="operator">=</span> <span class="number">5.0</span> / <span class="number">9</span> * (fahrenheit - <span class="number">100</span>); <span class="comment">//如果5/9,Java会处理成整数0</span></span><br><span class="line">System.out.println(<span class="string">&quot;华氏温度&quot;</span> + fahrenheit + <span class="string">&quot;对应的摄氏温度为&quot;</span> + </span><br><span class="line">centigrade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关系运算符(Relational Operator)</strong></p><p>&#x3D;&#x3D;, &gt;, &lt;, !&#x3D;等符号</p><p>instanceof 检查实例是否是某一个类的对象(字符串”zkq”是String类的对象)</p><p>可以将关系比较的结果赋值给一个布尔值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a &gt; b;</span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong></p><p>连接多个表达式，最终结果也是布尔值</p><p>短路：与&amp;&amp;，或||，取反！</p><p>逻辑：与&amp;，或|，异或^(异或就是比较真假，如果两个一个真一个假就说明不同返回true，两个都是真或都是假就说明相同返回false)</p><p><em>短路与和逻辑与的区别：当第一个条件是false的时候，短路与就不会判断第二个条件，而逻辑与会判断第二个条件，效率较低</em></p><p><em>短路或和逻辑或的区别：当第一个条件是true的时候，短路或就不会判断第二个条件，而逻辑或会判断第二个条件，效率较低</em></p><p><strong>赋值运算符</strong></p><p>先进行&#x3D;右边的计算，再将结果赋值给左边</p><p>&#x3D;右边可以是常量，变量，表达式，而左边只能是变量</p><p>赋值运算会自动类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">b += <span class="number">2</span>; <span class="comment">//这里等价于b = (byte)(b + 2);底层自动强制转换</span></span><br></pre></td></tr></table></figure><p>如果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">b = b + <span class="number">2</span>; <span class="comment">//这里就会报错，2是默认整型，完成加法后=右边是整型，int没法转byte</span></span><br></pre></td></tr></table></figure><p><strong>三元运算符</strong></p><p>条件表达式 ? 表达式1 : 表达式2;</p><p>若条件为真，则返回表达式1，为假返回2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a &lt; b ? a++ : b++; <span class="comment">//先返回a的值，然后a自增，表达式产生的结果必须为int，或强转</span></span><br><span class="line"><span class="comment">// 或者自动转换也可以，比如int自动转double</span></span><br><span class="line">System.out.println(result); <span class="comment">//这里是10</span></span><br><span class="line">System.out.println(a); <span class="comment">//a已经自增过了，为11</span></span><br></pre></td></tr></table></figure><p>还可以写成if else语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a &gt; b ? a++ : --b; <span class="comment">//可以写成下面的形式</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; b) result = a++;</span><br><span class="line"><span class="keyword">else</span> result = --b;</span><br></pre></td></tr></table></figure><p><em><strong>编程小练习</strong></em></p><p>实现三个数的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现三个数的最大值</span></span><br><span class="line"><span class="comment">定义三个变量num1，num2，num3</span></span><br><span class="line"><span class="comment">两次比较返回一个结果res</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">5</span>, num2 = <span class="number">2</span>, num3 = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> num1 &gt; num2 ? num1 : num2;</span><br><span class="line">res = res &gt; num3 ? res : num3;</span><br><span class="line">System.out.println(<span class="string">&quot;最大数为&quot;</span> + res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运算符优先级</strong></p><p>单目运算(++，–，！()等只针对一个变量运算的)和赋值运算都是从右向左(先搞&#x3D;右边)</p><p><strong>标识符(自己起名字的位置)</strong></p><p>规则：</p><ol><li><p>数字不能开头</p></li><li><p>不能使用关键字和保留字</p></li><li><p>不能包含空格</p></li></ol><p>规范，更加专业：</p><ol><li>包名，多个单词组成时所有字母都小写，aaa.bbb.ccc</li><li>类名，接口名的所有单词的首字母大写，比如AssignOperator，大驼峰命名方式</li><li>变量名，方法名的第一个单词首字母小写，第二个单词开始每个单词首字母大写，比如tankShotGame，小驼峰命名方式，也简称驼峰法</li><li>常量名，所有字母全大写，下划线连接单词，比如TAX_RATE</li></ol><p><strong>键盘输入语句</strong></p><p>使用Scanner类，分为3步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入/引入Scanner所在的包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">//将java.util下的Scanner类导入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//2. 创建Scanner对象实例，myScanner就是Scanner类的对象</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//new表示新创建对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入名字&quot;</span>);</span><br><span class="line"><span class="comment">//3. 然后使用相关方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> myScanner.next(); <span class="comment">//表示接受用户的输入的字符串，next是其中一个方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入年龄&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> myScanner.nextInt(); <span class="comment">//接受用户输入的int</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入薪水&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> myScanner.nextDouble(); <span class="comment">//接受用户输入的double</span></span><br><span class="line">System.out.println(<span class="string">&quot;人的信息如下：&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot; 年龄：&quot;</span> + age + <span class="string">&quot; 薪水：&quot;</span> + salary);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将.理解为“的”</p><p><strong>进制</strong></p><p>二进制：0，1，满2进1，以0b或0B开头(0b1010)</p><p>十进制：0-9，满10进1</p><p>八进制：0-7，满8进1，以数字0开头(01010)</p><p>十六进制：0-9以及A-F(10-15)，满16进1，以0x或0X开头，A-F不区分大小写(0x10101)</p><p><strong>进制转换</strong></p><p>分四组：</p><ol><li>其他进制转十进制</li><li>十进制转其他进制</li><li>二进制转其他进制</li><li>其他进制转二进制</li></ol><p><strong>其他进制转十进制</strong></p><ol><li><p>二转十：从最低位(右边)开始，将每个位上的数提取出来，乘2^(位数-1)次方，最后求和</p><p>0b1011转十进制：1*2^(1-1) + 1*2^(2-1) + 0*2^(3-1) + 1*2^(4-1) &#x3D; 11</p></li><li><p>八转十：从最低位(右边)开始，将每个位上的数提取出来，乘8^(位数-1)次方，最后求和</p><p>0234转十进制：4*8^0 + 3*8^1 + 2*8^2  &#x3D; 156</p></li><li><p>十六转十：从最低位(右边)开始，将每个位上的数提取出来，乘16^(位数-1)次方，最后求和</p><p>0x23A：10*16^0 + 3*16^1 + 2*16^2 &#x3D; 570</p></li></ol><p><strong>其他进制转二进制</strong></p><ol><li><p>十转二：将该数不断除以2，直到商为0为止，将每步的余数倒过来就是二进制，34转二进制</p><p>34&#x2F;2&#x3D;17……0</p><p>17&#x2F;2&#x3D;8……1</p><p>8&#x2F;2&#x3D;4……0</p><p>4&#x2F;2&#x3D;2……0</p><p>2&#x2F;2&#x3D;1……0</p><p>1&#x2F;2&#x3D;0……1</p><p>0&#x2F;2&#x3D;0</p><p>倒过来为0b100010，但不满一个字节的8位，所以需要用两个0填充高位，实际为0b00100010</p></li><li><p>十转八：将该数不断除以8，直到商为0为止，将每步的余数倒过来就是八进制，131转八进制</p><p>131&#x2F;8&#x3D;16……3</p><p>16&#x2F;8&#x3D;2……0</p><p>2&#x2F;8&#x3D;0……2</p><p>0&#x2F;8&#x3D;0</p><p>倒过来为0203</p></li><li><p>十转十六：将该数不断除以16，直到商为0为止，将每步的余数倒过来就是十六进制，237转十六进制</p><p>237&#x2F;16&#x3D;14……D(13)</p><p>14&#x2F;16&#x3D;0……E(14)</p><p>0&#x2F;16&#x3D;0</p><p>倒过来为0xED</p></li></ol><p><strong>二进制转八和十六进制</strong></p><ol><li><p>二转八：从低位开始，将二进制数每三位一组，转成对应的八进制数，0b11010101转八进制</p><p>11010<strong>101</strong>(5)</p><p>11<strong>010</strong>(2)101</p><p><strong>11</strong>(3)010101</p><p>合起来是0325</p></li><li><p>二转十六：从低位开始，将二进制数每四位一组，转成对应的十六进制数，0b11010101转十六进制</p><p>1101<strong>0101</strong>(5)</p><p><strong>1101</strong>(D)</p><p>合起来是0xD5</p></li></ol><p><strong>八和十六进制转二进制</strong></p><ol><li><p>八转二：将八进制数每一位都转成对应的一个三位的二进制数，0237转二进制</p><p>2&#x2F;2&#x3D;1……0</p><p>1&#x2F;2&#x3D;0……1</p><p>0&#x2F;2&#x3D;0(010)</p><p>3&#x2F;2&#x3D;1……1</p><p>1&#x2F;2&#x3D;0……1</p><p>0&#x2F;2&#x3D;0(011)</p><p>7&#x2F;2&#x3D;3……1</p><p>3&#x2F;2&#x3D;1……1</p><p>1&#x2F;2&#x3D;0……1</p><p>0&#x2F;2&#x3D;0(111)</p><p>合起来是010011111，舍掉多余的一个0，为0b10011111</p></li><li><p>十六转二：将十六进制数每一位都转成对应的一个四位的二进制数，0x23B转二进制</p><p>2(0010)</p><p>3(0011)</p><p>11(B)&#x2F;2&#x3D;5……1</p><p>5&#x2F;2&#x3D;2……1</p><p>2&#x2F;2&#x3D;1……0</p><p>1&#x2F;2&#x3D;0……1</p><p>0&#x2F;2&#x3D;0(1011)</p><p>合起来是0010 0011 1011，为0b001000111011</p></li></ol><p><strong>位运算</strong></p><p>&gt;&gt;向右位移(1&gt;&gt;2表示1向右位移2位)</p><p>&gt;&gt;&gt;算数右移</p><p><del>按位取反(</del>2)</p><p>&amp;按位与(2&amp;3表示2按位与3)</p><p>|按位或</p><p>^按位异或</p><h4 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h4><p>对于有符号的：</p><ol><li>二进制的最高位是符号位，0表示正数，1表示负数</li><li>正数的原码反码补码都一样，三码合一</li><li>负数的反码&#x3D;它的原码符号位不变，其他位取反</li><li>负数的补码&#x3D;它的反码+1，负数的反码&#x3D;负数的补码-1</li><li>0的反码补码都是0</li><li>java没有无符号数，java中的数都有符号</li><li>计算机运算的时候都是以补码的方式来运算(补码会将正负数统一起来)</li><li>当看到运算结果的时候要看它的原码(计算机自动转成原码给用户看)</li></ol><p><strong>位运算符详解</strong>(BitOperator)</p><p>按位与&amp;：两个二进制数一位一位的比较，若两个位全是1，则为1，否则为0</p><p>按位或|：两个二进制数一位一位的比较，若两个位有一个是1，则为1，否则为0</p><p>按位异或^：两个位相同，则为0，不同则为1</p><p>按位取反~：0变成1，1变成0</p><p><em>举例：2&amp;3</em></p><ol><li><p>先得到2的补码，所以先取2的原码为00000000 00000000 00000000 00000010(2是int型，所以4字节)</p></li><li><p>正数三码合一，所以补码也是00000000 00000000 00000000 00000010</p></li><li><p>得到3的补码，和上面一样，补码和原码都是00000000 00000000 00000000 00000011</p></li><li><p>按位&amp;，将两个数的补码拿来</p><p>00000000 00000000 00000000 00000010</p><p>00000000 00000000 00000000 00000011</p><p>得到：</p><p>00000000 00000000 00000000 00000010</p></li><li><p>上述是运算后的补码，计算机会自动转成原码，但补码符号位是0，所以是正数，三码合一</p></li><li><p>得到原码00000000 00000000 00000000 00000010，结果是2</p></li></ol><p><em>举例2：~-2</em></p><ol><li>先得到-2的补码，所以先取-2的原码为10000000 00000000 00000000 00000010(最高位符号位为1)</li><li>对于负数，要先得到反码，符号位不变，其他位取反，为 11111111 11111111 11111111 11111101</li><li>这时就可以得到补码，反码加一，为 11111111 11111111 11111111 11111110</li><li>进行取反操作00000000 00000000 00000000 00000001，符号位是0，正数，三码合一</li><li>最后直接得到原码，00000000 00000000 00000000 00000001，结果是1</li></ol><p><em>举例3：~2</em></p><ol><li>先得到2的补码，补码&#x3D;原码为00000000 00000000 00000000 00000010</li><li>补码取反为11111111 11111111 11111111 11111101</li><li>因为补码符号位为1，所以要先得到反码</li><li>反码&#x3D;补码-1&#x3D;11111111 11111111 11111111 11111100</li><li>最后反码符号位不变，其他位取反，得到原码为10000000 00000000 00000000 00000011，为-3</li></ol><p><strong>位运算符详解2</strong></p><p>还有三个位运算符&gt;&gt;, &lt;&lt;, &gt;&gt;&gt;</p><p>算术右移&gt;&gt;：低位溢出，符号位不变，并用符号位补溢出的高位</p><p>算数左移&lt;&lt;：符号位不变，低位补0</p><p>逻辑右移&gt;&gt;&gt;：无符号右移，低位溢出，高位补0(没有&lt;&lt;&lt;符号)</p><p><em>举例4：1&gt;&gt;2</em></p><ol><li>1的原码和补码为00000000 00000000 00000000 00000001</li><li>右移2位后为<strong>00</strong>000000 00000000 00000000 00000000(00)，高位补的是符号位的数</li><li>三码合一，结果为0(结果相当于1&#x2F;2&#x2F;2 &#x3D; 0，右移一次除一个2)</li></ol><p><em>举例5：1&lt;&lt;2</em></p><ol><li>1的原码和补码为00000000 00000000 00000000 00000001</li><li>左移2位后为(00)00000000 00000000 00000000 000001<strong>00</strong></li><li>三码合一，结果为4(相当于1*2*2&#x3D;4，左移一次乘一个2)</li></ol><p>-1&gt;&gt;2</p><ol><li>-1原码为10000000 00000000 00000000 00000001</li><li>-1反码为11111111 11111111 11111111 11111110</li><li>-1补码&#x3D;反码+1&#x3D;11111111 11111111 11111111 11111111</li><li>右移2位11111111 11111111 11111111 11111111</li><li>反码&#x3D;补码-1&#x3D;11111111 11111111 11111111 11111110</li><li>原码为10000000 0000000 0000000 00000001为-1</li></ol><h3 id="Java学习第五章"><a href="#Java学习第五章" class="headerlink" title="Java学习第五章"></a>Java学习第五章</h3><h4 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h4><p><strong>顺序结构</strong></p><p>从上到下，中间没有任何判断和跳转</p><p>向前引用原则：先定义再使用</p><p><strong>分支控制</strong></p><p>单分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>() &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>() &#123;</span><br><span class="line">……</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多分支(多分支可以没有else)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>() &#123;</span><br><span class="line">……</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">……</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套分支</p><p>if里套if(不超过三层)</p><p><strong>switch基本语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="comment">//表达式会返回一个值</span></span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>: <span class="comment">//表达式的值与常量1匹配时，执行语句块1</span></span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//一个也没有匹配上，执行语句块default</span></span><br><span class="line">        语句块<span class="keyword">default</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：</p><ol><li><p>表达式的数据类型应和case一样，或者可以自动转成相互比较的类型，字符和int可以</p></li><li><p>表达式的返回值必须是byte，short，int，char，enum，String</p></li><li><p>case的值必须是常量或常量表达式计算式(1+1)，不能是变量(就是一个具体的值，不能被改变的值)</p></li><li><p>default可选，没有也可以</p></li><li><p>有break就会跳出switch，没有就会顺序执行到switch的结尾(直接穿透执行每个语句块，不再比较case)，除非遇到break(穿透现象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">    语句块<span class="number">1</span>; <span class="comment">//没有break，下一步直接执行语句块2，case相当于一次性入口</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">    语句块<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//这里遇到break结束switch</span></span><br></pre></td></tr></table></figure></li></ol><p><em>编程练习</em></p><p>当表达式的值要匹配多个常量的时候，没有case 1 | 2这种写法，应该使用穿透</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求3，4，5输出春季，6，7，8输出夏季以此类推，用switch</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入月份：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> myScanner.nextInt();</span><br><span class="line"><span class="keyword">switch</span>(month) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> : <span class="comment">//使用穿透，使得3，4，5使用的是一个输出结果，相当于3或4或5</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> :</span><br><span class="line">System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span> :</span><br><span class="line">System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span> :</span><br><span class="line">System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：如果是区间判断用if比较好，如果判断的具体值不多，符合byte，short，int，char，enum，String则用switch</p><h4 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量初始化; 循环条件; 循环变量迭代) &#123;</span><br><span class="line">    循环操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：</p><ol><li>循环条件返回布尔值，i &lt;&#x3D; 10的结果是布尔值</li><li>初始化和变量迭代可以写在其他地方，但两边的;不能丢</li><li>for(;;)表示无限循环</li></ol><p><strong>while循环</strong></p><p><strong>do while循环</strong></p><p>do while最后有一个;</p><h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><p>一个循环放在另一个循环内，一般不超过三层</p><p><em>编程练习</em></p><ol><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计三个班的成绩，每班5个学生，求出各班平均分和所有班级的平均分</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> <span class="variable">sumStu</span> <span class="operator">=</span> <span class="number">0</span>, sumClass = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">classes</span> <span class="operator">=</span> <span class="number">1</span>; classes &lt;= <span class="number">3</span>; classes++) &#123; <span class="comment">//以班级数外循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="number">1</span>; stu &lt;= <span class="number">5</span>; stu++) &#123; <span class="comment">//以学生数内循环</span></span><br><span class="line">System.out.print(<span class="string">&quot;请输入第&quot;</span> + classes + <span class="string">&quot;个班级的第&quot;</span> + stu + <span class="string">&quot;个同学的成绩&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> myScanner.nextDouble(); <span class="comment">//依次输入学生成绩</span></span><br><span class="line">sumStu += score; <span class="comment">//学生总成绩累加5次</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span> + classes + <span class="string">&quot;个班的平均分为&quot;</span> + sumStu / <span class="number">5</span>); <span class="comment">//学生平均分</span></span><br><span class="line">sumClass += sumStu; <span class="comment">//班级总成绩累加3次</span></span><br><span class="line">sumStu = <span class="number">0</span>; <span class="comment">//学生总成绩归零以便下一个班级重新累加</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;三个班的平均分为&quot;</span> + sumClass / <span class="number">15</span>); <span class="comment">//总平均分</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先死后活，将班级数和学生数调整为变量便于后期修改值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计三个班的成绩，每班5个学生，求出各班平均分和所有班级的平均分</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> <span class="variable">sumStu</span> <span class="operator">=</span> <span class="number">0</span>, sumClass = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numStu</span> <span class="operator">=</span> <span class="number">5</span>, numClass = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">classes</span> <span class="operator">=</span> <span class="number">1</span>; classes &lt;= numClass; classes++) &#123; <span class="comment">//以班级数外循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="number">1</span>; stu &lt;= numStu; stu++) &#123; <span class="comment">//以学生数内循环</span></span><br><span class="line">System.out.print(<span class="string">&quot;请输入第&quot;</span> + classes + <span class="string">&quot;个班级的第&quot;</span> + stu + <span class="string">&quot;个同学的成绩&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> myScanner.nextDouble(); <span class="comment">//依次输入学生成绩</span></span><br><span class="line">sumStu += score; <span class="comment">//学生总成绩累加numStu次</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;第&quot;</span> + classes + <span class="string">&quot;个班的平均分为&quot;</span> + sumStu / numStu); <span class="comment">//学生平均分</span></span><br><span class="line">sumClass += sumStu; <span class="comment">//班级总成绩累加numClass次</span></span><br><span class="line">sumStu = <span class="number">0</span>; <span class="comment">//学生总成绩归零以便下一个班级重新累加</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;三个班的平均分为&quot;</span> + sumClass / numClass * numStu); <span class="comment">//总平均分</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印九九乘法表</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123; <span class="comment">//第一个乘数的遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123; <span class="comment">//第二个乘数的遍历，到两个乘数相等的时候停止内循环，然后换行</span></span><br><span class="line">System.out.print(j + <span class="string">&quot; x &quot;</span> + i + <span class="string">&quot; = &quot;</span> + i * j + <span class="string">&quot;\t&quot;</span>); <span class="comment">//输出，当乘数相等时停止</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;\n&quot;</span>); <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印金字塔</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入金字塔的层数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> myScanner.nextInt(); <span class="comment">//输入金字塔的层数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= level; i++) &#123; <span class="comment">//遍历每一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= level - i; k++) &#123; <span class="comment">//实现空格的输出,空格个数是总层数-当前层数</span></span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++) &#123; <span class="comment">//实现*的输出，*数=当前层*2 - 1</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(<span class="string">&quot;\n&quot;</span>); <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印空心金字塔</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入金字塔的层数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> myScanner.nextInt(); <span class="comment">//输入金字塔的层数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= level; i++) &#123; <span class="comment">//遍历每一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= level - i; k++) &#123; <span class="comment">//实现*前空格的输出,空格个数是总层数-当前层数</span></span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++) &#123; <span class="comment">//*的输出，*数=当前层*2 - 1，但仅限首尾或最后一行</span></span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">1</span> || j == <span class="number">2</span> * i - <span class="number">1</span> || i == level) &#123; <span class="comment">//仅限首尾或最后一行才输出*</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>); <span class="comment">//其他情况就输出空格</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>); <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印空心菱形</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入菱形的层数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> myScanner.nextInt(); <span class="comment">//输入菱形的层数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= level; i++) &#123; <span class="comment">//遍历每一层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先处理前半段的空格和*</span></span><br><span class="line"><span class="keyword">if</span>(i &lt;= level / <span class="number">2</span>) &#123; <span class="comment">//前半段的空格</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= level / <span class="number">2</span> + <span class="number">1</span> - i; k++) &#123; <span class="comment">//空格数是总层数/2 +1-当前层数</span></span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出前半段的*</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++) &#123; <span class="comment">//*的输出，*数=当前层*2 - 1</span></span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">1</span> || j == <span class="number">2</span> * i - <span class="number">1</span>) &#123; <span class="comment">//仅限首尾或最后一行才输出*</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>); <span class="comment">//其他情况就输出空格</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再处理后半段的空格和*</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//后半段的空格</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= i - level / <span class="number">2</span> - <span class="number">1</span>; k++) &#123; <span class="comment">//空格为当前层数-总层数/2 - 1</span></span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出后半段的*</span></span><br><span class="line">                <span class="comment">//总位置数=(level - i + 1)*2 - 1，仅首尾输出*</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= (level - i + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">1</span> || j == (level - i + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>) &#123; <span class="comment">//仅限首尾才输出*</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot; &quot;</span>); <span class="comment">//其他情况就输出空格</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>); <span class="comment">//换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>break语句</strong></p><p>break语句可以通过标签来决定退出哪一层循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">label1:</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    ……</span><br><span class="line">    label2:</span><br><span class="line">    <span class="keyword">for</span>(……) &#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">break</span> lable2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：字符串比较的时候不是&#x3D;&#x3D;，而是”常量”.equals(变量)</p><p><strong>return</strong>表示退出方法</p><p>当return用在方法中，表示退出方法，用在main，表示退出程序</p><h3 id="Java学习第六章"><a href="#Java学习第六章" class="headerlink" title="Java学习第六章"></a>Java学习第六章</h3><h4 id="数组排序查找"><a href="#数组排序查找" class="headerlink" title="数组排序查找"></a>数组排序查找</h4><p><strong>数组</strong></p><p>多个<em>同一类型</em>的数据，数组也是一种数据类型，是引用类型</p><p>数组的长度为数组名.length</p><p>数组名[下标&#x2F;索引]</p><p>数组型数据的本质是对象</p><p><strong>首先应该创建数组</strong>：</p><p>数据类型 数组名[] &#x3D; new 数据类型[数组长度]</p><p>double score[] &#x3D; new double[5]; &#x2F;&#x2F;这是动态初始化</p><p>直接int a[] &#x3D; {1, 2, 3}; &#x2F;&#x2F;这是静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次键盘输入5个数，然后输出</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">double</span> score[] = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span>]; <span class="comment">//直接创建一个长度为5的double类型的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; score.length; i++) &#123; </span><br><span class="line">System.out.print(<span class="string">&quot;请输入第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;个数&quot;</span>);</span><br><span class="line">score[i] = myScanner.nextDouble(); <span class="comment">//动态赋值，根据下标变化一个一个赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; score.length; i++) &#123; <span class="comment">//遍历数组</span></span><br><span class="line">System.out.print(score[i] + <span class="string">&quot; &quot;</span>); <span class="comment">//循环输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候先声明再创建数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]; <span class="comment">//只声明int类型数组，在内存中还没有分配空间，为空null</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; <span class="comment">//再创建一个长度为10的数组，分配了内存空间，可以存放数据</span></span><br></pre></td></tr></table></figure><p><em>编程练习</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入A-Z，输出</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">char</span> cha[] = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>]; <span class="comment">//长度为26，26个英文字母</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cha.length; i++) &#123;</span><br><span class="line">cha[i] = (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i); <span class="comment">//char和int混合运算结果会转成int类型，不能自动转char，所以需要强转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cha.length; i++) &#123; <span class="comment">//遍历输出</span></span><br><span class="line">System.out.print(cha[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组分配-x2F-赋值机制"><a href="#数组分配-x2F-赋值机制" class="headerlink" title="数组分配&#x2F;赋值机制"></a>数组分配&#x2F;赋值机制</h4><p>基本数据类型的赋值是值拷贝&#x2F;传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> n1; <span class="comment">//因为是值拷贝，所以这里n2的变化不会影响n1</span></span><br></pre></td></tr></table></figure><p>数组是引用传递，赋的值实际上是地址，具体的堆里面的值arr1和arr2共用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = arr1; <span class="comment">//因为是引用传递，拷贝的是地址，所以arr2的变化会影响arr1</span></span><br></pre></td></tr></table></figure><p>要想两个数组各自独立空间</p><p>需要创建一个新的数组arr2，开辟新的数据空间，大小为arr1.length</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length]; <span class="comment">//新开了一个arr2数组，新开了一个数据空间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123; <span class="comment">//遍历arr1，将arr1的每个元素拷贝到arr2对应的新空间</span></span><br><span class="line">arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>编程练习</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将&#123;11, 22, 33, 44, 55, 66, 77&#125;反转输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//初始化一个临时变量，用于交换</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr1.length; <span class="comment">//为了方便，将数组长度赋给一个变量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">temp = arr1[i]; <span class="comment">//交换前后两个数值，用临时变量</span></span><br><span class="line">arr1[i] = arr1[arr1.length - i - <span class="number">1</span>];</span><br><span class="line">arr1[arr1.length - i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2，新数组，逆序赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将&#123;11, 22, 33, 44, 55, 66, 77&#125;反转输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr1.length;</span><br><span class="line"><span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[len]; <span class="comment">//创建了一个新的数组arr2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">//遍历arr1</span></span><br><span class="line">arr2[i] = arr1[len - i - <span class="number">1</span>]; <span class="comment">//将arr1的元素逆序依次赋值给arr2正序的位置上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">System.out.print(arr2[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组添加</strong>(扩容)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个数组，询问是否添加元素，最终对数组扩容</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//arr1初始</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr1.length; <span class="comment">//优化，将arr1长度赋给一个变量</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="comment">//创造循环询问环境</span></span><br><span class="line">System.out.print(<span class="string">&quot;是否继续添加元素,y/n：&quot;</span>);</span><br><span class="line"><span class="type">char</span> <span class="variable">answer</span> <span class="operator">=</span> myScanner.next().charAt(<span class="number">0</span>); <span class="comment">//创建一个字符变量接收答案</span></span><br><span class="line"><span class="keyword">if</span>(answer == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;输入希望添加的数值：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> myScanner.nextInt(); <span class="comment">//创建一个整型变量接收要添加的数值</span></span><br><span class="line"><span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>]; <span class="comment">//创建一个新的数组arr2，长度在arr1基础上加一</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">//遍历arr1</span></span><br><span class="line">arr2[i] = arr1[i]; <span class="comment">//将arr1的原始元素依次赋给arr2</span></span><br><span class="line">&#125;</span><br><span class="line">arr2[len] = num; <span class="comment">//单独将新元素赋给最后一个位置</span></span><br><span class="line">arr1 = arr2; <span class="comment">//将arr2地址直接拷贝给arr1，引用传递，共享一个数据实现arr1的扩容</span></span><br><span class="line">len++; <span class="comment">//len表示arr1的长度还是原先的数值，这里需要更新加一</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(answer == <span class="string">&#x27;n&#x27;</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;添加完毕，结果如下&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：使用do while更好，先添加一个再询问</p><p>内部排序：将要处理的所有数据都加载到内存中进行排序(交换式排序，选择排序等)</p><p>外部排序：数据量过大，需要借助外部存储排序(合并排序法，直接合并排序)</p><p>冒泡排序：将数组从后往前每个元素依次比较，逆序交换(不管从小到大还是从大到小，冒泡法每趟都是将最后一个位置确定)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序，动态比较两个位置的值，两个索引一起变化，大值放最后</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">24</span>, <span class="number">69</span>, <span class="number">80</span>, <span class="number">57</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//初始化临时变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123; <span class="comment">//外层表示趟，一共走四趟，固定四次最后一个位置</span></span><br><span class="line"><span class="comment">//确定了后四个位置第一个位置也确定了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123; <span class="comment">//内层表示每趟比较的次数，因为第二趟开始最后一位固定</span></span><br><span class="line"><span class="comment">//所以不用比较最后两个</span></span><br><span class="line"><span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">//具体比较前后两个元素的大小，交换大数放后</span></span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序，静态比较两个位置的值，单个索引变化，从小到大排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">24</span>, <span class="number">69</span>, <span class="number">80</span>, <span class="number">57</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//初始化临时变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123; <span class="comment">//取四个位置固定和其他数比较，最后一个位置不必要取</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">//每趟固定本趟第一个位置最小，且第一个位置不用自己比较自己</span></span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; arr[j]) &#123; <span class="comment">//依次比较选择的这个数和它后面的数，交换</span></span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串数组的查找</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">String arr[] = &#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line">System.out.print(<span class="string">&quot;请输入名字：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> myScanner.next();</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(name.equals(arr[i])) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;恭喜你，找到了，下标为&quot;</span> + i);</span><br><span class="line">index = <span class="number">1</span>; <span class="comment">//用了一个索引index，一旦找到了，index值随即改变</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;没找到&quot;</span>); <span class="comment">//一旦没找到，index保持原来的值0，以此来完成整体else</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维数组</strong></p><p>一维数组的每一个元素又是一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二维数组输出</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">3 3 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]; <span class="comment">//创建二维数组arr[][]，由于已知一维的大小3，所以直接写，二维不写，因为长度不确定，要在后面才确定</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>]; <span class="comment">//动态创建每一个一维数组里的元素(数组)，由于上面初始化二维数组的时候没有写二维的大小，所以这里动态给出每个元素(数组)大小</span></span><br><span class="line"><span class="comment">//且每次长度加一</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123; <span class="comment">//遍历每一个一维数组下的元素(数组)</span></span><br><span class="line">arr[i][j] = i + <span class="number">1</span>; <span class="comment">//由于行数和每个二维数组里的元素相同，arr[i][j]表示具体数值元素的位置</span></span><br><span class="line"><span class="comment">//行数为i+1，i为下标</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">//遍历一维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123; <span class="comment">//遍历二维数组，即一维数组的每一个元素</span></span><br><span class="line">System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>); <span class="comment">//动态输出</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>); <span class="comment">//每输出一个一位数组元素(数组)换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>编程练习</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//杨辉三角</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">1 3 3 1</span></span><br><span class="line"><span class="comment">1 4 6 4 1</span></span><br><span class="line"><span class="comment">每行第一个都是1，arr[i][0] = 1</span></span><br><span class="line"><span class="comment">每行最后一个也都是1，arr[i][arr[i].length]</span></span><br><span class="line"><span class="comment">第二个开始，值=上一行的相同位置arr[i - 1][j]+前一个位置arr[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>]; <span class="comment">//创建每一个一维数组元素(数组)的大小，行数=大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">0</span> || j == arr[i].length - <span class="number">1</span>) &#123; <span class="comment">//表示元素(数组)的第一个和最后一个位置</span></span><br><span class="line">arr[i][j] = <span class="number">1</span>; <span class="comment">//这两个位置是1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//其余位置是arr[i - 1][j] + arr[i - 1][j - 1];</span></span><br><span class="line">arr[i][j] = arr[i - <span class="number">1</span>][j] + arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">System.out.print(arr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：int[] x, y[]; 这里x是一维数组，y是二维数组([]y[])，int[]是一个整体，而y也带着一个[]，所以二维</p><p>数组这样定义也可以：String strs[] &#x3D; new String[]{“a”, “b”, “c”};(不能少了[]，也不能[3]框里写了大小但是后面仍然写了具体的元素)</p><p><em>编程练习</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有一个升序的数组，要求插入一个数，仍然是升序</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123;<span class="number">10</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">90</span>&#125;;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入插入的数值：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> myScanner.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//存放插入数值的位置值，同时作为索引判断是不是所有元素都没插入值大</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr1.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">//遍历arr1，找出插入数值位置</span></span><br><span class="line"><span class="keyword">if</span>(num &lt; arr1[i]) &#123;</span><br><span class="line">position = i; <span class="comment">//将插入的位置赋给position</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(position == -<span class="number">1</span>) &#123;</span><br><span class="line">position = len; <span class="comment">//若遍历完发现插入值最大，则手动赋值position在最后一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>]; <span class="comment">//创建arr2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i++) &#123; <span class="comment">//遍历arr2</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; position) &#123; <span class="comment">//以插入位置为界分批赋值</span></span><br><span class="line">arr2[i] = arr1[i]; <span class="comment">//插入位置前的赋值，一一对应</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == position) &#123;</span><br><span class="line">arr2[i] = num; <span class="comment">//插入位置的赋值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr2[i] = arr1[i - <span class="number">1</span>]; <span class="comment">//插入位置后的赋值，相同下标，arr2的值和arr1下标减一相同</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr1 = arr2; <span class="comment">//引用传递</span></span><br><span class="line">System.out.print(<span class="string">&quot;插入后数组为：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>); <span class="comment">//输出arr1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java学习第七章"><a href="#Java学习第七章" class="headerlink" title="Java学习第七章"></a>Java学习第七章</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p><strong>类与对象</strong>(OOP)</p><p>引入类与对象的原因就是现有技术不能完美解决新的需求</p><p><em><strong>对象 (属性 (有什么)和行为 (可以干什么))</strong></em></p><p>类是一种自定义的数据类型(int是java提供的数据类型)</p><p>对象就是该类里具体的一个实例，创建一个对象，实例化一个对象，将类实例化表示一个意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123; <span class="comment">//创建一个猫类</span></span><br><span class="line"><span class="comment">//猫类的属性</span></span><br><span class="line">String name; <span class="comment">//定义猫的名字</span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//定义猫的年龄</span></span><br><span class="line">String color; <span class="comment">//定义猫的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//猫类的行为</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">//实例化一个猫对象，赋给cat1</span></span><br><span class="line">cat1.name = <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">cat1.age = <span class="number">2</span>;</span><br><span class="line">cat1.color = <span class="string">&quot;白色&quot;</span>;</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">//实例化另一个猫对象，赋给cat2</span></span><br><span class="line">cat2.name = <span class="string">&quot;小黄&quot;</span>;</span><br><span class="line">cat2.age = <span class="number">5</span>;</span><br><span class="line">cat2.color = <span class="string">&quot;黄色&quot;</span>;</span><br><span class="line"><span class="comment">//访问两个猫对象的信息</span></span><br><span class="line">System.out.println(<span class="string">&quot;第一只猫的信息：&quot;</span> + cat1.name + <span class="string">&quot; &quot;</span> + cat1.age + <span class="string">&quot; &quot;</span> + cat1.color);</span><br><span class="line">System.out.println(<span class="string">&quot;第二只猫的信息：&quot;</span> + cat2.name + <span class="string">&quot; &quot;</span> + cat2.age + <span class="string">&quot; &quot;</span> + cat2.color);</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123; <span class="comment">//创建一个猫类</span></span><br><span class="line"><span class="comment">//猫类的属性(成员变量)</span></span><br><span class="line">String name; <span class="comment">//定义猫的名字</span></span><br><span class="line"><span class="type">int</span> age; <span class="comment">//定义猫的年龄</span></span><br><span class="line">String color; <span class="comment">//定义猫的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//猫类的行为(方法)</span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象在内存中的存在形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//对应1，2，3</span></span><br><span class="line">p1.age = <span class="number">10</span>; <span class="comment">//对应4</span></span><br><span class="line">p1.name = <span class="string">&quot;小明&quot;</span>; <span class="comment">//对应5</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1; <span class="comment">//对应6</span></span><br></pre></td></tr></table></figure><ol><li>在方法区加载Person类的信息(属性(成员变量)和行为(方法)) (只会加载一次)</li><li>堆中开辟了三个区域表示三个属性，值是默认值(字符串默认为null)</li><li>栈中，将地址(堆中三个区域)赋给p1，所以p指向对象(在堆中)</li><li>指定初始化(赋值)，对于基本数据类型直接找到堆中的整型空间将0换成10</li><li>但其中名字和颜色为字符串，字符串也是引用类型，所以会继续指向一个系统分配的地址，地址在方法区的常量池里有两个区域，分别已经存放名字和颜色的字符串信息</li><li>p1地址拷贝给p2</li></ol><p>Note：</p><ol><li><p>成员变量 &#x3D; 属性 &#x3D; field(字段)</p></li><li><p>属性也可以是引用类型，数组和字符串</p></li><li><p>cat1只是对象名，并不是对象本体，它只是指向对象的地址</p></li><li><p>栈：一般存放基本数据类型(局部变量)</p></li><li><p>堆：存放对象</p></li><li><p>方法区：常量，比如字符串，类加载信息</p></li><li><p>p &#x3D; null; 表示切断堆栈之间的联系，置空，抛出异常</p></li></ol><p><strong>访问修饰符</strong>：控制属性的访问范围(public; protected; private; 默认)</p><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><p>定义成员方法(就是行为)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123; <span class="comment">//添加方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;我是一个好人&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主方法中的speak方法调用</span></span><br><span class="line">p1.speak();</span><br></pre></td></tr></table></figure><p>void表示没有返回的数据</p><p>如果void变为int等类型，表示方法执行后返回一个int值，需要有return x;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal02</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n + m;</span><br><span class="line"><span class="keyword">return</span> sum; <span class="comment">//sum的值返回给主方法后可以赋给一个变量来接收，用于后续使用</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法调用</span></span><br><span class="line">p1.speak();</span><br><span class="line">p1.cal01(<span class="number">5</span>);</span><br><span class="line">p1.cal01(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">cal02Test</span> <span class="operator">=</span> p1.cal02(<span class="number">5</span>, <span class="number">10</span>); <span class="comment">//定义了cal02Test接收cal02方法返回的值</span></span><br><span class="line">System.out.println(cal02Test + <span class="number">1</span>); <span class="comment">//接收之后输出</span></span><br></pre></td></tr></table></figure><p>方法调用底层原理：</p><ol><li>当程序执行到调用方法时，系统会开辟一个新的空间(栈空间)</li><li>当方法执行完毕时，或执行到return时，就会返回</li><li>返回到调用方法的地方，然后临时开辟的栈空间会自动销毁</li><li>返回后继续执行方法后面的代码，执行完后main栈也退出，程序结束</li></ol><p>Note：</p><ol><li><p>一个方法最多返回一个结果，用数组可以多个，将多个结果封装到一个数组中返回</p></li><li><p>返回类型可以是引用类型，数组或对象</p></li><li><p>非void必须要有return，return可以是常量，变量，表达式，若非void是double，则return后的值必须也是double或int，因为int可以转成double，参数传入的时候同理</p></li><li><p>方法名要有含义</p></li><li><p>方法不能再方法里面定义</p></li><li><p><strong>再同一个类里面，一个方法里面要调用到另一个方法，直接写 方法名(值) 即可</strong></p></li><li><p>类A里面的一个方法要调用类B里面的一个方法，需要通过对象名调用</p><p>所以需要在类A的那个方法中创建一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//创建一个B类的新对象</span></span><br><span class="line">B.方法名();</span><br></pre></td></tr></table></figure></li></ol><h4 id="方法传参机制"><a href="#方法传参机制" class="headerlink" title="方法传参机制"></a>方法传参机制</h4><p>如果传递的数据是引用类型，比如数组，对象的属性</p><p>a. 那么主方法的数组传给自定义方法，在方法里面对数组的修改会影响主方法中的数组，因为指向的都是堆中的同一个空间</p><p>b. 如果是将主方法里面创建的对象p传给自定义类B里方法的p，那么在方法里修改另一个类的对象的属性，这个属性会永久修改，后续调用的这个对象的属性也是被修改过后的，因为对象也存在堆中，大家都指向它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//创建一个Person类的一个对象p</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//创建一个B类的对象b</span></span><br><span class="line">p.age = <span class="number">10</span>; <span class="comment">//修改p的属性age=10</span></span><br><span class="line">b.test(p); <span class="comment">//调用b对象的test方法，传入对象p</span></span><br><span class="line">System.out.println(p.age); <span class="comment">//调用以后age已经被test方法修改成了99</span></span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意对象是存在堆中，从头到尾只创建了一个新的p对象，所以堆中只有一个空间存age，谁改都会永久改变它</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Person p)</span> &#123; <span class="comment">//定义一个test方法，可以传入一个对象p，且这个对象是Person类的对象</span></span><br><span class="line">p.age = <span class="number">99</span>; <span class="comment">//修改p的属性age=99，和主方法都是在同一个堆的位置修改，age先在主方法里被改成了10</span></span><br><span class="line"><span class="comment">//然后又调用本方法，再次去到同一个位置将age修改成了99</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若p.age &#x3D; null，只置空自己，让自己不再指向堆中存放Person属性age的空间，但是它无法使Person的age属性也置空，它仍然指向堆中的相应空间，所以主方法调用它不会什么也不输出</p><p>若在B类里面，当给test方法传入p对象时，重新创建一个新对象，这个对象属于test方法自己的，然后将传入的p给到这个新对象，再修改p的属性age，但此时在堆中又新开了一个空间，使得test方法里的p指向了新空间里的新age，但不影响原来的空间里的age，最后新开的空间会被垃圾回收，因为没有调用它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//创建一个Person类的一个对象p，在堆中开辟了一个空间1，由p指向</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//创建一个B类的对象b</span></span><br><span class="line">p.age = <span class="number">10</span>; <span class="comment">//在空间1中修改p的属性age=10</span></span><br><span class="line">b.test(p); <span class="comment">//调用b对象的test方法，传入对象p</span></span><br><span class="line">System.out.println(p.age); <span class="comment">//调用以后age仅在空间2中被修改为99，但主方法这里还是空间1，所以还是10</span></span><br><span class="line"><span class="comment">//test里面创建的空间2没有被使用，被垃圾回收</span></span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意对象是存在堆中，从头到尾主方法和test方法各创建了一个新的p对象</span></span><br><span class="line"><span class="comment">//所以堆中有两个空间存age，各修改各自的</span></span><br><span class="line"><span class="comment">//创建对象时，=左边Person p表示定义一个Person类的对象p，=右边new Person();表示新开一个空间在堆中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Person p)</span> &#123; <span class="comment">//定义一个test方法，可以传入一个对象p，且这个对象是Person类的对象</span></span><br><span class="line">p = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//在堆中另开一块空间2，但还是由p指向</span></span><br><span class="line">        <span class="comment">//因为这里的p是传进来的对象，已经定义了它是Person类的对象，所以不需要写前面那个Person</span></span><br><span class="line">p.age = <span class="number">99</span>; <span class="comment">//修改p的属性age=99，这里修改就是在这块新空间2中修改age为99，不影响原来的空间1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>编程练习</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，可以复制Person类的对象，来复制对象的属性，比如age，然后返回复制好的对象</span></span><br><span class="line"><span class="comment">//要求复制的对象和原来的对象互相独立</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//创建一个Person类的一个对象p，在堆中开辟了一个空间1</span></span><br><span class="line"><span class="type">Copy</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Copy</span>(); <span class="comment">//创建一个B类的对象b</span></span><br><span class="line">p.age = <span class="number">10</span>; <span class="comment">//在空间1中修改p的属性age=10</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> copy.copyPerson(p); <span class="comment">//调用Copy类里的copyPerson方法，传入对象p</span></span><br><span class="line"><span class="comment">//返回值也是一个Person类的对象pNew赋给同样也是Person类的对象p1，p1是在这一步新创建的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> copy.copyPerson(p); <span class="comment">//同理</span></span><br><span class="line">System.out.println(p1.age); <span class="comment">//分别输出两个新空间里的age</span></span><br><span class="line">System.out.println(p2.age); <span class="comment">//两个新空间里的age都是通过一个方法赋值的</span></span><br><span class="line"><span class="comment">//且赋的值都是原先的值，所以都是10，实现复制</span></span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法调用了两次copyPerson方法，所以一共新开辟了三个空间在堆中，第一个是空间1，是主方法开的</span></span><br><span class="line"><span class="comment">//其余两个是调用的copyPerson方法里面开的，三个空间互相独立，修改age互不影响，但后两个空间用的是一个方法开辟的</span></span><br><span class="line"><span class="comment">//所以复制出来的对象的age一模一样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copy</span> &#123;</span><br><span class="line"><span class="comment">//要返回对象类型，不能写void</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">copyPerson</span><span class="params">(Person p0)</span> &#123; <span class="comment">//定义一个方法，可以传入一个Person类的对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">pNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//在test方法中新创建一个pNew对象，会在堆中另开一块空间</span></span><br><span class="line">pNew.age = p0.age; <span class="comment">//将传入的p0对象的age值10赋给新的pNew对象</span></span><br><span class="line"><span class="keyword">return</span> pNew; <span class="comment">//返回一个Person对象类型的值pNew</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//编写一个方法，可以复制Person类的对象，来复制对象的属性，比如age，然后返回复制好的对象</span></span><br><span class="line"><span class="comment">//要求复制的对象和原来的对象互相独立</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//创建一个Person类的一个对象p，在堆中开辟了一个空间1</span></span><br><span class="line"><span class="type">Copy</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Copy</span>(); <span class="comment">//创建一个B类的对象b</span></span><br><span class="line">p.age = <span class="number">10</span>; <span class="comment">//在空间1中修改p的属性age=10</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> copy.copyPerson(p); <span class="comment">//调用Copy类里的copyPerson方法，传入对象p</span></span><br><span class="line"><span class="comment">//返回值也是一个Person类的对象赋给同样也是Person类的对象p1，p1是在这一步新创建的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> copy.copyPerson(p); <span class="comment">//同理</span></span><br><span class="line">System.out.println(p1.age); <span class="comment">//分别输出两个新空间里的age</span></span><br><span class="line">System.out.println(p2.age); <span class="comment">//两个新空间里的age都是通过一个方法赋值的，所以都是99，实现复制</span></span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主方法调用了两次copyPerson方法，所以一共新开辟了三个空间在堆中，第一个是空间1，是主方法开的</span></span><br><span class="line"><span class="comment">//其余两个是调用的copyPerson方法里面开的，三个空间互相独立，修改age互不影响，但后两个空间用的是一个方法开辟的</span></span><br><span class="line"><span class="comment">//所以复制出来的对象的age一模一样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copy</span> &#123;</span><br><span class="line"><span class="comment">//要返回对象类型，不能写void</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">copyPerson</span><span class="params">(Person p0)</span> &#123; <span class="comment">//定义一个方法，可以传入一个Person类的对象</span></span><br><span class="line">p0 = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//在test方法中新创建一个p0对象，会在堆中另开一块空间</span></span><br><span class="line">p0.age = <span class="number">99</span>; <span class="comment">//修改p的属性age=99，这里修改就是在这块新空间中修改age为99</span></span><br><span class="line"><span class="keyword">return</span> p0; <span class="comment">//返回一个Person对象类型的值p</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法递归调用</strong>：方法中再调方法自己，每次可以传入不同的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> map[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span> || i == <span class="number">7</span> || j == <span class="number">0</span> || j == <span class="number">6</span>) &#123;</span><br><span class="line">map[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//然后考虑程序什么时候结束，当位置是map[6][5]的时候结束，需要接收一个true值</span></span><br><span class="line"><span class="type">Find</span> <span class="variable">find</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Find</span>();</span><br><span class="line">find.findWay(map, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">//将地图和起点传入findWay方法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123; <span class="comment">//输出整个地图，因为数组是引用数据类型，地图是二维数组</span></span><br><span class="line"><span class="comment">//所以在方法中改了地图就相当于地图永久被改变，所以只需要让方法返回来就可以了，所以用布尔值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义位置标记，0表示可以探索，还没有动过</span></span><br><span class="line"><span class="comment">//1表示障碍物</span></span><br><span class="line"><span class="comment">//定义2表示通路，表示当前位置是可以走到目的地的通路上的其中一个位置</span></span><br><span class="line"><span class="comment">//定义3表示死胡同，都走不通且已经走过</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Find</span> &#123;</span><br><span class="line"><span class="comment">//找路这个方法的本质就是看看这个位置到底能不能通往目的地，能就返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findWay</span><span class="params">(<span class="type">int</span> map[][], <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123; <span class="comment">//定义一个表示传入位置的形参列表</span></span><br><span class="line"><span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">//当[6][5]位置置2时说明已经有通路到了目的地，返回true</span></span><br><span class="line"><span class="comment">//注意这里的true是返回给前一个要探索它的位置</span></span><br><span class="line"><span class="comment">//每一次该方法被调用的第一件事就是看65位置是不是已经是2了</span></span><br><span class="line"><span class="comment">//到了目的地以后其实还要再找一次路，但是方法被调用的时候第一件事就是判断目的地是不是2</span></span><br><span class="line"><span class="comment">//这时发现目的地已经置2了，所以直接返回true到主方法中</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//说明这个位置还没有来过，先给他赋上2(最难想的点)</span></span><br><span class="line">map[i][j] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//因为是从左上角往右下角走，所以遵循下，右，上，左的原则</span></span><br><span class="line"><span class="keyword">if</span>(findWay(map, i + <span class="number">1</span>, j)) &#123; <span class="comment">//if里如果是true，就表示它下面那个位置可以去到目的地</span></span><br><span class="line"><span class="comment">//所以这里也返回true来告诉它的前一个位置(不一定是上)我能通往目的地</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(findWay(map, i, j + <span class="number">1</span>)) &#123; <span class="comment">//同理，不过它表示的是当前位置的右边</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(findWay(map, i - <span class="number">1</span>, j)) &#123; <span class="comment">//同理，不过它表示的是当前位置的右边</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(findWay(map, i, j - <span class="number">1</span>)) &#123; <span class="comment">//同理，不过它表示的是当前位置的右边</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//当前位置三面都走不通的时候，因为有一面是它的前一个位置已经先被置2了</span></span><br><span class="line"><span class="comment">/*前一个位置还在等待它的结果，但是前一个是2，再加上现在它自己其他三面都走不通</span></span><br><span class="line"><span class="comment">所以等于现在四面都走不通，只能将自己原来的置2置成3，表示死胡同，前一个位置接收到false以后</span></span><br><span class="line"><span class="comment">就会按下右上左继续找路，以此类推</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//除了目的地是2或者当前位置是0，其余情况都false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法重载</strong></p><p>比如println可以输入各种类型的数据，因为在system类的out对象，是printstream类型</p><p>在同一个类，允许相同的方法名存在，称为方法重载，但形参列表不一致</p><p><strong>可变参数</strong></p><p>同一个类中多个同名同功能但参数不同的方法，封装成一个方法</p><p>比如写一个方法计算两个数的和，三，四，五个数的和</p><p>格式：public 返回类型 方法名(数据类型…形参名) </p><p>比如：public int sum(int…nums)可以接收多个int(接收大于等于0个参数)</p><p>可以将nums当作一个数组处理，比如总共传入了nums.length个参数，可以遍历nums求和等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zkq&quot;</span>;</span><br><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">test.totalScore(name, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">totalScore</span><span class="params">(String name, <span class="type">double</span>...score)</span> &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; score.length; i++) &#123;</span><br><span class="line">sum += score[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;总成绩为&quot;</span> + sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的<strong>作用域</strong></p><ol><li>变量的作用域主要指成员变量(属性)和局部变量</li><li>局部变量一般指在方法中定义的变量，代码块里面的变量也是局部变量</li><li>全局变量：属性，作用域为整个类体，当时定义的猫的属性age就是全局变量，或者可以通过创建对象的方式给其他类用</li><li>属性，全局变量可以不赋值，因为有默认值，比如int age的默认值就是0，字符串是null</li><li>属性和局部变量可以重复，用的时候就近原则</li><li>方法调用一次，局部变量创建一次，方法调用完毕，局部变量销毁，但是属性和对象挂钩，对象销毁，属性才销毁</li></ol><p><strong>构造方法&#x2F;构造器</strong></p><p>语法：[修饰符] 方法名(形参列表) {方法体}</p><ol><li>构造器没有返回值</li><li>方法名和类名必须一致</li><li>构造器的调用由系统完成</li><li>创建对象时，系统自动调用构造器来初始化对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zkq&quot;</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zkq&quot;</span>, <span class="number">21</span>); <span class="comment">//创建对象p时系统自动调用构造器对name和age进行了一个指定</span></span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">String name;</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName, <span class="type">int</span> pAge)</span> &#123;</span><br><span class="line">age = pAge;</span><br><span class="line">name = pName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​Note：</p><ol><li><p>一个类可以定义多个不同的构造器，构造器重载</p></li><li><p>若我们没有定义构造器，系统会默认生成一个无参构造器(默认构造器)</p></li><li><p>javap工具可以将class文件内容反编译为我们可以看懂的代码</p><p>命令：javap Dog.class</p></li><li><p>定义了自己的构造器，还想用默认无参构造器，需要显式的定义一下无参构造器：Dog() {}</p><p>自己的构造器需要在主方法中写new Dog(“name”, age); 如果这时还想什么都不写，那就需要上述</p></li><li><p>无参构造器和默认无参构造器要区分，无参构造器自己也可以写，里面可以定义age，使得所有的dog类的对象都是18岁</p></li></ol><p><strong>创建对象流程分析</strong></p><ol><li>加载Person类信息(Person.class)，只会加载一次</li><li>在堆中分配空间(地址)</li><li>完成对象的默认初始化，属性默认赋值，age是0</li><li>显式初始化，属性里面赋值，age&#x3D;90</li><li>构造器初始化，进一步赋值构造器中的值</li><li>方法区常量池分配空间写进字符串数据</li><li>由堆中对象空间指向常量池</li><li>栈中对象名地址返回给p，指向堆中真正的对象</li></ol><p><strong>this关键字</strong></p><p>如果定义构造器的时候将构造器形参列表里的变量直接写成属性名，如name就写name会更好</p><p>但是出现一个问题，根据作用域就近原则</p><p>构造器里的name不再是属性哪里定义的name，而是构造器形参列表里定义的name</p><p>所以造成name&#x3D;name，由于是局部变量，所以和属性没关系，所以输出默认值0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    name = name;</span><br><span class="line">    age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是引出this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name; <span class="comment">//this指向当前对象的属性name和age</span></span><br><span class="line">    <span class="built_in">this</span>.age = age; <span class="comment">//谁调用这个构造器那这个this就是谁的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以理解为this也是一个隐藏的属性指向堆中的自己，this就代表本对象</p><p>Note：</p><ol><li><p>this可以访问本类的属性，方法，构造器</p></li><li><p>this用于区分当前类的属性和局部变量</p></li><li><p>访问成员方法的语法：this.方法名(参数列表)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">    f1(); <span class="comment">//调用f1()方法</span></span><br><span class="line">    <span class="built_in">this</span>.f1(); <span class="comment">//也是调用f1()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用this(参数列表); 即只能在<em><strong>构造器</strong></em>中访问另外一个构造器</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">T</span><span class="params">()</span> &#123; <span class="comment">//创建一个无参构造器</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;zkq&quot;</span>, <span class="number">21</span>); <span class="comment">//访问构造器，且这条必须放在第一条语句</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; <span class="comment">//创建一个构造器</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>this不能再类的外部使用，只能在类定义的方法中使用</li></ol><p><em>this编程练习</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法比较两个对象是否一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zkq&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zyj&quot;</span>, <span class="number">21</span>); </span><br><span class="line">System.out.println(<span class="string">&quot;比较的结果为：&quot;</span> + p1.compare(p2));</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">String name;</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age; <span class="comment">//指定当前对象的年龄为传入的值</span></span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(Person p)</span> &#123; <span class="comment">//比较方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age; <span class="comment">//本对象(看谁调用)的和传入的对象比较</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java学习第十章"><a href="#Java学习第十章" class="headerlink" title="Java学习第十章"></a>Java学习第十章</h3><p><strong>类变量和类方法</strong></p><p>类变量(静态变量)：为了解决一个问题，避免独立的变量与类结合编程，使得变量可以让所有的类共享，static</p><p>在Child类里面写：</p><p>public static int count &#x3D; 0;——该变量最大的特点就是可以被所有该类的对象共享，所有对象的count都指向同一个空间</p><p>且类变量可以直接通过类名.来访问(Child.count), 它和child1.count，child2.count值是一样的</p><p>静态变量两种说法：1. 存放在堆空间中，count静态变量存放在类对应的class实例对象的尾部，而这个class对象在堆中，所以认为静态变量也在堆中(<strong>静态变量会在类加载的时候就会生成，所以没有创建对象实例也可以访问</strong>) (JDK8之后)，2.存放在方法区的静态域</p><p><strong>类变量使用细节：</strong></p><p>当需要用到每个对象都需要用到的变量时就可以做成类变量(static静态变量)</p><p><strong>类方法同理</strong>：比如Math类，如果希望不创建实例对象也可以调用该类的方法，即将它当作一个工具，则这时可以将它做成静态方法</p><p>静态方法只能访问静态成员(静态变量和静态方法)，<strong>且不能用this关键字</strong></p><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>mian方法是Java虚拟机在调用的，且必须是public因为不在一个类</p><p>必须是static，java虚拟机执行时不必要创建对象</p><p>String args形参数组在程序执行时在命令行将字符串数组传入(java Test jack smith john)</p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>属于类的成员，类似于方法，只有方法体</p><p>可以修饰符，写static表示静态代码块{</p><p>​……</p><p>}</p><p>相当于另一种形式的构造器，也可以初始化操作</p><p>若多个构造器中有重复的语句，就可以抽出来写在代码块中</p><p>后续不管调用哪个构造器，都会<strong>先</strong>调用代码块中的内容</p><p><strong>静态代码块</strong></p><p>随类的加载而执行，<strong>只会执行一次</strong>，那么什么时候类加载？</p><ol><li>当创建实例对象new的时候</li><li>创建子类实例对象，父类也会被加载，且父类先被加载，子类再被加载</li><li>使用类的静态属性或静态方法时会被加载，若有父类，则还是先加载父类</li></ol><p>而普通代码块每被<strong>创建一次对象</strong>就会被执行</p><p><em><strong>创建一个对象时在一个类里面的调用顺序：</strong></em></p><ol><li>先执行静态代码块和静态属性初始化，二者优先级一样，若同时存在，则看谁先写，即谁先定义</li><li>直接去看子类构造器，跳到构造器规则：<ol><li>先super到父类的构造器，若父类往上就没有父类了，然后就搞父类的普通代码块和普通属性初始化</li><li>看谁写在前面，先执行谁，都执行完后再真正执行父类构造器，然后回到子类</li><li>看子类的普通代码块和普通属性初始化谁在前</li><li>最后真正执行子类的构造器内容</li></ol></li></ol><p><em><strong>构造器规则：</strong></em></p><p>public A {</p><p>这里会隐藏一个super()，第二行隐藏了调用本类代码块，所以先调用父类的构造器，然后看父类有没有普通代码块，然后再回来执行自己的代码块</p><p>}</p><p>Note：</p><ol><li>静态代码块只能调用静态成员，普通代码块可以调用任意成员</li><li>类的加载，比如主方法想要调用静态属性的时候就会完成类的加载，注意这里类的加载是整体的，也就是静态属性初始化和静态代码块会直接按顺序执行完毕，代码块的内容被执行，这个过程不能断开</li><li>静态属性初始化，这里的属性有可能是创建的另一个类的对象</li></ol><h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><p>单个实例简称单例</p><p>目的是保证在程序运行过程中保证一个类只能有一个实例对象</p><p>饿汉式：</p><ol><li>构造器私有化，防止用户直接new对象</li><li>类的内部创建对象</li><li>向外公开一个静态的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">g1</span> <span class="operator">=</span> GirlFriend.getGirlFriend(); <span class="comment">//接收对象，不管定义几个g1，接收的都是同一个对象</span></span><br><span class="line">        <span class="comment">//这里因为getGirlFriend是静态公开的，所以这里可以直接用类名调用</span></span><br><span class="line">        System.out.println(g1); <span class="comment">//输出对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//私有化姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123; <span class="comment">//私有化构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">girlFriend</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;小红&quot;</span>); </span><br><span class="line">    <span class="comment">//创建对象必须静态，因为get方法是静态的，get里要调用的对象也必须是静态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getGirlFriend</span><span class="params">()</span> &#123; <span class="comment">//静态方法为了让主方法可以用类名调用</span></span><br><span class="line">        <span class="keyword">return</span> girlFriend; <span class="comment">//如果对象不是静态初始化的话，这里会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">//可以输出对象的属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是饿汉式可能会造成创建了对象，但是没有使用，造成资源的浪费</p><p>懒汉式只是用的时候才创建</p><p>懒汉式：</p><ol><li><p>构造器私有化</p></li><li><p>内部先定义一个对象引用名，用来后续接收对象</p></li><li><p>创建静态公开的get方法供主方法调用</p></li><li><p>再get内if语句，判断现在的对象是不是空的，如果不是，说明已经创建了一个对象，就不需要再创建</p><p>若是空的，则创建new一个对象实例赋给之前的对象引用名</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">g1</span> <span class="operator">=</span> GirlFriend.getGirlFriend(); <span class="comment">//接收对象，不管定义几个g1，接收的都是同一个对象</span></span><br><span class="line">        <span class="comment">//这里因为getGirlFriend是静态公开的，所以这里可以直接用类名调用</span></span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">g2</span> <span class="operator">=</span> GirlFriend.getGirlFriend();</span><br><span class="line">        System.out.println(g1); <span class="comment">//输出对象</span></span><br><span class="line">        System.out.println(g2); <span class="comment">//输出对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//私有化姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123; <span class="comment">//私有化构造器，外部不能再new</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GirlFriend girlFriend; <span class="comment">//不给对象属性值，只定义对象引用名，所以默认对象为空null</span></span><br><span class="line">    <span class="comment">//创建对象必须静态，因为get方法是静态的，get里要调用的对象也必须是静态的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getGirlFriend</span><span class="params">()</span> &#123; <span class="comment">//静态方法为了让主方法可以用类名调用</span></span><br><span class="line">        <span class="keyword">if</span>(girlFriend == <span class="literal">null</span>) &#123; <span class="comment">//判断此时对象是不是空</span></span><br><span class="line">            girlFriend = <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;小红&quot;</span>); <span class="comment">//如果是空，则利用构造器给对象引用名赋值，真正创建对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> girlFriend; <span class="comment">//返回对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">//可以输出对象的属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ol><li><p>希望这个类就是最终的子类，不希望再被继承被重写</p><p>final class A，这样别的类就不能再继承A了</p></li><li><p>可以用final修饰方法，这样这个方法就不会被子类的方法重写</p><p>public final void hi()</p></li><li><p>用final修饰属性，这样类的属性就不会被修改</p><p>public final double age &#x3D; 10.0</p></li><li><p>比如在一个类的一个方法里定义的一个局部变量不想被修改</p><p>final double NUM &#x3D; 0.01 (一般不能被改变的变量名全大写)</p></li></ol><p>Note：</p><ol><li><p>变量名一般全部大写，中间用下划线隔开 TAX_NUM</p></li><li><p>一般在定义的时候就要直接赋值，或再构造器里赋值，因为final写在定义的时候，直接赋值以后就不改变了</p></li><li><p>如果写final的变量或方法是静态的，则初始化的时候不能再构造器中，可以在静态代码块中赋值</p><p>因为构造器是创建对象new的时候才会使用构造器，所以有可能就不创建对象，而final要求必须再定义的时候就要给值，这时可能还没有new，所以就会矛盾，而写在代码块中，因为代码块和静态初始胡变量一样都在类加载的时候就会执行，所以不管有没有new对象，定义是静态的，代码块也是静态的，就可以直接赋值</p></li><li><p>final了一个类，便不能继承，但是是可以实例化对象的</p></li><li><p>类已经是final了，方法就不需要final了</p></li><li><p>构造器不能final</p></li><li><p>**要想在类里面定义一个变量属性，但是主方法中只想调用这个属性值，不想加载类方法，就可以定义属性的时候写上public final static int n &#x3D; 500;</p><p>这时候底层会做一个优化，调用n的时候就只会输出500，不会加载这个类方法</p></li><li><p>包装类，String都是final类，都不能被继承</p></li><li><p>形参可以写成(final int x)，这样的话在方法内就不能修改x的值了</p></li></ol><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>当父类的一个方法存在的意义只是作为程序调用的入口，真正执行的是被重写的子类，而父类不知道该写什么，这时这个方法就可以称为抽象方法</p><p>可以写成：public abstract void eat() , 但是一旦方法写成抽象方法，类也必须修饰为抽象类，这里注意一旦修饰成抽象类，方法体就不能写了</p><p>Note：</p><ol><li>抽象类不能实例化，不能new</li><li>抽象类可以没有抽象方法</li><li>abstract只能修饰类和方法</li><li>抽象类本质还是类，各种成员都能有</li><li>一个子类继承了抽象类，则所有抽象方法必须在子类里得到实现(实现方法就是要有同名方法的方法体)，或者子类也修饰成抽象的</li><li>抽象方法不能使用private，final或static，因为这些和重写违背</li></ol><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>给出一些没有实现的方法，封装到一起，到某个类使用的时候，根据具体情况将这些方法写出来</p><p>定义接口，语法：、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123; <span class="comment">//这里定义了一个接口类</span></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//方法(抽象方法且在接口中，abstract可以省略，默认实现方法要加default修饰，静态方法加static)</span></span><br><span class="line">&#125;</span><br><span class="line">class 类名 implements 接口名&#123; <span class="comment">//这里相当于手机，相机等外设</span></span><br><span class="line">自己的属性</span><br><span class="line">    自己的方法，必须实现接口的抽象方法</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口可以统一管理，统一方法名</p><p>举例实现，两个程序员使用同一个接口编写连接mysql和oracle数据库的代码，最后直接调用接口</p><ol><li><p>定义接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DBInterface</span> &#123; <span class="comment">//定义了一个接口DBInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>; <span class="comment">//创建了一个抽象方法，固定了连接数据库方法的方法名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;<span class="comment">//创建了一个抽象方法，固定了断开数据库方法的方法名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第一个程序员编写连接mysql数据库的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBMySQL</span> <span class="keyword">implements</span> <span class="title class_">DBInterface</span>&#123; <span class="comment">//定义连接断开mysql的类，实现接口DBInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123; <span class="comment">//定义一个连接mysql的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MySQL已连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; <span class="comment">//定义一个断开mysql的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MySQL断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二个程序员编写连接Oracle数据库的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBOracle</span> <span class="keyword">implements</span> <span class="title class_">DBInterface</span>&#123; <span class="comment">//定义连接断开Oracle的类，实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123; <span class="comment">//定义一个连接Oracle的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle已连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; <span class="comment">//定义一个断开Oracle的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle断开连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后通过接口实现统一管理自动识别输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DBMySQL</span> <span class="variable">dbMySQL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBMySQL</span>(); <span class="comment">//创建一个连接断开mysql数据库的类的对象</span></span><br><span class="line">        <span class="type">DBOracle</span> <span class="variable">dbOracle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBOracle</span>(); <span class="comment">//创建一个连接断开mysql数据库的类的对象</span></span><br><span class="line">        <span class="comment">//然后调用action方法</span></span><br><span class="line">        action(dbMySQL); <span class="comment">//将mysql对象传入action方法</span></span><br><span class="line">        action(dbOracle); <span class="comment">//将oracle对象传入action方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(DBInterface db)</span> &#123; <span class="comment">//定义一个可以统一实现功能的方法</span></span><br><span class="line">        <span class="comment">//必须是静态的，因为主方法要调用这个action方法，主方法是静态的，所以这里也必须是静态的</span></span><br><span class="line">        <span class="comment">//传入一个已经实现DBInterface接口的类</span></span><br><span class="line">        db.connect(); <span class="comment">//直接用传入的对象调用接口里面的方法</span></span><br><span class="line">        db.shutdown(); <span class="comment">//就能自动识别是哪个数据库，然后输出相应的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ol><li>接口不能实例化</li><li>接口中的方法都是public</li><li>光标放在要实现接口的类的implements上，按alt+enter快速重写方法</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
